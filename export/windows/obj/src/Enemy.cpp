// Generated by Haxe 4.0.0-rc.2+77068e10c
#include <hxcpp.h>

#ifndef INCLUDED_Enemy
#include <Enemy.h>
#endif
#ifndef INCLUDED_Entity
#include <Entity.h>
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxObject
#include <flixel/FlxObject.h>
#endif
#ifndef INCLUDED_flixel_FlxSprite
#include <flixel/FlxSprite.h>
#endif
#ifndef INCLUDED_flixel_animation_FlxAnimationController
#include <flixel/animation/FlxAnimationController.h>
#endif
#ifndef INCLUDED_flixel_math_FlxAngle
#include <flixel/math/FlxAngle.h>
#endif
#ifndef INCLUDED_flixel_math_FlxPoint
#include <flixel/math/FlxPoint.h>
#endif
#ifndef INCLUDED_flixel_math_FlxRandom
#include <flixel/math/FlxRandom.h>
#endif
#ifndef INCLUDED_flixel_math__FlxVector_FlxVector_Impl_
#include <flixel/math/_FlxVector/FlxVector_Impl_.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPooled
#include <flixel/util/IFlxPooled.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_c595a05c1c7a687d_8_new,"Enemy","new",0x35d4571a,"Enemy.new","Enemy.hx",8,0xbda88996)
static const int _hx_array_data_03a88228_1[] = {
	(int)0,(int)1,(int)2,(int)3,(int)4,(int)5,(int)6,(int)7,(int)8,(int)9,(int)10,(int)11,(int)12,(int)13,(int)14,(int)15,(int)16,
};
HX_LOCAL_STACK_FRAME(_hx_pos_c595a05c1c7a687d_33_update,"Enemy","update",0xcf0e6f8f,"Enemy.update","Enemy.hx",33,0xbda88996)
HX_LOCAL_STACK_FRAME(_hx_pos_c595a05c1c7a687d_39_setHealthByWave,"Enemy","setHealthByWave",0x83c0a168,"Enemy.setHealthByWave","Enemy.hx",39,0xbda88996)
HX_LOCAL_STACK_FRAME(_hx_pos_c595a05c1c7a687d_42_setRandomVelocityVariedByWave,"Enemy","setRandomVelocityVariedByWave",0x63c4cb6d,"Enemy.setRandomVelocityVariedByWave","Enemy.hx",42,0xbda88996)
HX_LOCAL_STACK_FRAME(_hx_pos_c595a05c1c7a687d_62_chasePlayer,"Enemy","chasePlayer",0xbd884469,"Enemy.chasePlayer","Enemy.hx",62,0xbda88996)

void Enemy_obj::__construct(int wave, ::Entity playerToChase){
            	HX_GC_STACKFRAME(&_hx_pos_c595a05c1c7a687d_8_new)
HXLINE(  12)		this->random =  ::flixel::math::FlxRandom_obj::__alloc( HX_CTX ,null());
HXLINE(  10)		 ::flixel::math::FlxPoint this1 =  ::flixel::math::FlxPoint_obj::__alloc( HX_CTX ,( (Float)(0) ),( (Float)(0) ));
HXDLIN(  10)		this->_velocity = this1;
HXLINE(  15)		super::__construct(null(),null(),null());
HXLINE(  17)		this->loadGraphic(HX_("assets/images/zombie/zombie_running.png",5f,d2,43,cf),true,288,311,null(),null());
HXLINE(  18)		this->animation->add(HX_("move",11,e3,60,48),::Array_obj< int >::fromData( _hx_array_data_03a88228_1,17),16,true,null(),null());
HXLINE(  19)		this->animation->play(HX_("move",11,e3,60,48),null(),null(),null());
HXLINE(  21)		this->setGraphicSize(24,24);
HXLINE(  22)		this->updateHitbox();
HXLINE(  24)		this->_playerToChase = playerToChase;
HXLINE(  26)		this->setHealthByWave(wave);
HXLINE(  27)		this->setRandomVelocityVariedByWave(wave);
HXLINE(  29)		this->_velocity->set_x(( (Float)(0) ));
HXLINE(  30)		this->_velocity->set_y(( (Float)(0) ));
            	}

Dynamic Enemy_obj::__CreateEmpty() { return new Enemy_obj; }

void *Enemy_obj::_hx_vtable = 0;

Dynamic Enemy_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< Enemy_obj > _hx_result = new Enemy_obj();
	_hx_result->__construct(inArgs[0],inArgs[1]);
	return _hx_result;
}

bool Enemy_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x25a685e0) {
		if (inClassId<=(int)0x0b6ffd77) {
			if (inClassId<=(int)0x03a88228) {
				return inClassId==(int)0x00000001 || inClassId==(int)0x03a88228;
			} else {
				return inClassId==(int)0x0b6ffd77;
			}
		} else {
			return inClassId==(int)0x25a685e0;
		}
	} else {
		return inClassId==(int)0x2e105115 || inClassId==(int)0x39b08743;
	}
}

void Enemy_obj::update(Float elapsed){
            	HX_STACKFRAME(&_hx_pos_c595a05c1c7a687d_33_update)
HXLINE(  34)		this->super::update(elapsed);
HXLINE(  35)		this->chasePlayer();
            	}


void Enemy_obj::setHealthByWave(int wave){
            	HX_STACKFRAME(&_hx_pos_c595a05c1c7a687d_39_setHealthByWave)
HXDLIN(  39)		this->health = ( (Float)((2 + wave)) );
            	}


HX_DEFINE_DYNAMIC_FUNC1(Enemy_obj,setHealthByWave,(void))

void Enemy_obj::setRandomVelocityVariedByWave(int wave){
            	HX_STACKFRAME(&_hx_pos_c595a05c1c7a687d_42_setRandomVelocityVariedByWave)
HXLINE(  43)		Float speed;
HXLINE(  45)		if ((wave == 0)) {
HXLINE(  46)			speed = this->random->_hx_float(20,40,null());
            		}
            		else {
HXLINE(  47)			if ((wave == 1)) {
HXLINE(  48)				speed = this->random->_hx_float(40,80,null());
            			}
            			else {
HXLINE(  49)				if ((wave == 2)) {
HXLINE(  50)					speed = this->random->_hx_float(40,100,null());
            				}
            				else {
HXLINE(  51)					if ((wave == 3)) {
HXLINE(  52)						speed = this->random->_hx_float(80,100,null());
            					}
            					else {
HXLINE(  53)						if ((wave == 4)) {
HXLINE(  54)							speed = this->random->_hx_float(100,150,null());
            						}
            						else {
HXLINE(  56)							speed = this->random->_hx_float(80,200,null());
            						}
            					}
            				}
            			}
            		}
HXLINE(  59)		this->ENEMY_SPEED = speed;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Enemy_obj,setRandomVelocityVariedByWave,(void))

void Enemy_obj::chasePlayer(){
            	HX_STACKFRAME(&_hx_pos_c595a05c1c7a687d_62_chasePlayer)
HXLINE(  63)		this->_velocity->set_x((this->_playerToChase->x - this->x));
HXLINE(  64)		this->_velocity->set_y((this->_playerToChase->y - this->y));
HXLINE(  65)		::flixel::math::_FlxVector::FlxVector_Impl__obj::normalize(this->_velocity);
HXLINE(  66)		this->_velocity->scale(this->ENEMY_SPEED);
HXLINE(  68)		this->velocity->set_x(this->_velocity->x);
HXLINE(  69)		this->velocity->set_y(this->_velocity->y);
HXLINE(  71)		this->set_angle((::flixel::math::FlxAngle_obj::angleBetween(this->_playerToChase,hx::ObjectPtr<OBJ_>(this),true) - ( (Float)(180) )));
            	}


HX_DEFINE_DYNAMIC_FUNC0(Enemy_obj,chasePlayer,(void))


hx::ObjectPtr< Enemy_obj > Enemy_obj::__new(int wave, ::Entity playerToChase) {
	hx::ObjectPtr< Enemy_obj > __this = new Enemy_obj();
	__this->__construct(wave,playerToChase);
	return __this;
}

hx::ObjectPtr< Enemy_obj > Enemy_obj::__alloc(hx::Ctx *_hx_ctx,int wave, ::Entity playerToChase) {
	Enemy_obj *__this = (Enemy_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(Enemy_obj), true, "Enemy"));
	*(void **)__this = Enemy_obj::_hx_vtable;
	__this->__construct(wave,playerToChase);
	return __this;
}

Enemy_obj::Enemy_obj()
{
}

void Enemy_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Enemy);
	HX_MARK_MEMBER_NAME(_playerToChase,"_playerToChase");
	HX_MARK_MEMBER_NAME(_velocity,"_velocity");
	HX_MARK_MEMBER_NAME(ENEMY_SPEED,"ENEMY_SPEED");
	HX_MARK_MEMBER_NAME(random,"random");
	 ::flixel::FlxSprite_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void Enemy_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(_playerToChase,"_playerToChase");
	HX_VISIT_MEMBER_NAME(_velocity,"_velocity");
	HX_VISIT_MEMBER_NAME(ENEMY_SPEED,"ENEMY_SPEED");
	HX_VISIT_MEMBER_NAME(random,"random");
	 ::flixel::FlxSprite_obj::__Visit(HX_VISIT_ARG);
}

hx::Val Enemy_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"random") ) { return hx::Val( random ); }
		if (HX_FIELD_EQ(inName,"update") ) { return hx::Val( update_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"_velocity") ) { return hx::Val( _velocity ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"ENEMY_SPEED") ) { return hx::Val( ENEMY_SPEED ); }
		if (HX_FIELD_EQ(inName,"chasePlayer") ) { return hx::Val( chasePlayer_dyn() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"_playerToChase") ) { return hx::Val( _playerToChase ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"setHealthByWave") ) { return hx::Val( setHealthByWave_dyn() ); }
		break;
	case 29:
		if (HX_FIELD_EQ(inName,"setRandomVelocityVariedByWave") ) { return hx::Val( setRandomVelocityVariedByWave_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

hx::Val Enemy_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"random") ) { random=inValue.Cast<  ::flixel::math::FlxRandom >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"_velocity") ) { _velocity=inValue.Cast<  ::flixel::math::FlxPoint >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"ENEMY_SPEED") ) { ENEMY_SPEED=inValue.Cast< Float >(); return inValue; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"_playerToChase") ) { _playerToChase=inValue.Cast<  ::Entity >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void Enemy_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("_playerToChase",13,b5,02,c8));
	outFields->push(HX_("_velocity",7c,f9,93,66));
	outFields->push(HX_("ENEMY_SPEED",d0,6e,16,d2));
	outFields->push(HX_("random",03,22,8f,b7));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static hx::StorageInfo Enemy_obj_sMemberStorageInfo[] = {
	{hx::fsObject /*  ::Entity */ ,(int)offsetof(Enemy_obj,_playerToChase),HX_("_playerToChase",13,b5,02,c8)},
	{hx::fsObject /*  ::flixel::math::FlxPoint */ ,(int)offsetof(Enemy_obj,_velocity),HX_("_velocity",7c,f9,93,66)},
	{hx::fsFloat,(int)offsetof(Enemy_obj,ENEMY_SPEED),HX_("ENEMY_SPEED",d0,6e,16,d2)},
	{hx::fsObject /*  ::flixel::math::FlxRandom */ ,(int)offsetof(Enemy_obj,random),HX_("random",03,22,8f,b7)},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo *Enemy_obj_sStaticStorageInfo = 0;
#endif

static ::String Enemy_obj_sMemberFields[] = {
	HX_("_playerToChase",13,b5,02,c8),
	HX_("_velocity",7c,f9,93,66),
	HX_("ENEMY_SPEED",d0,6e,16,d2),
	HX_("random",03,22,8f,b7),
	HX_("update",09,86,05,87),
	HX_("setHealthByWave",ae,eb,b3,9e),
	HX_("setRandomVelocityVariedByWave",33,44,f3,1a),
	HX_("chasePlayer",af,73,ab,67),
	::String(null()) };

hx::Class Enemy_obj::__mClass;

void Enemy_obj::__register()
{
	Enemy_obj _hx_dummy;
	Enemy_obj::_hx_vtable = *(void **)&_hx_dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_("Enemy",28,82,a8,03);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = hx::Class_obj::dupFunctions(Enemy_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< Enemy_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Enemy_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Enemy_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

