// Generated by Haxe 4.0.0-rc.2+77068e10c
#include <hxcpp.h>

#ifndef INCLUDED_Entity
#include <Entity.h>
#endif
#ifndef INCLUDED_HUD
#include <HUD.h>
#endif
#ifndef INCLUDED_PlayState
#include <PlayState.h>
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_Survivor
#include <Survivor.h>
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxG
#include <flixel/FlxG.h>
#endif
#ifndef INCLUDED_flixel_FlxGame
#include <flixel/FlxGame.h>
#endif
#ifndef INCLUDED_flixel_FlxObject
#include <flixel/FlxObject.h>
#endif
#ifndef INCLUDED_flixel_FlxSprite
#include <flixel/FlxSprite.h>
#endif
#ifndef INCLUDED_flixel_FlxState
#include <flixel/FlxState.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedGroup
#include <flixel/group/FlxTypedGroup.h>
#endif
#ifndef INCLUDED_flixel_input_FlxBaseKeyList
#include <flixel/input/FlxBaseKeyList.h>
#endif
#ifndef INCLUDED_flixel_input_FlxKeyManager
#include <flixel/input/FlxKeyManager.h>
#endif
#ifndef INCLUDED_flixel_input_IFlxInput
#include <flixel/input/IFlxInput.h>
#endif
#ifndef INCLUDED_flixel_input_IFlxInputManager
#include <flixel/input/IFlxInputManager.h>
#endif
#ifndef INCLUDED_flixel_input_keyboard_FlxKeyList
#include <flixel/input/keyboard/FlxKeyList.h>
#endif
#ifndef INCLUDED_flixel_input_keyboard_FlxKeyboard
#include <flixel/input/keyboard/FlxKeyboard.h>
#endif
#ifndef INCLUDED_flixel_math_FlxPoint
#include <flixel/math/FlxPoint.h>
#endif
#ifndef INCLUDED_flixel_text_FlxText
#include <flixel/text/FlxText.h>
#endif
#ifndef INCLUDED_flixel_text_FlxTextBorderStyle
#include <flixel/text/FlxTextBorderStyle.h>
#endif
#ifndef INCLUDED_flixel_ui_FlxButton
#include <flixel/ui/FlxButton.h>
#endif
#ifndef INCLUDED_flixel_ui_FlxTypedButton_flixel_text_FlxText
#include <flixel/ui/FlxTypedButton_flixel_text_FlxText.h>
#endif
#ifndef INCLUDED_flixel_util_FlxSpriteUtil
#include <flixel/util/FlxSpriteUtil.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPooled
#include <flixel/util/IFlxPooled.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_ds_IntMap
#include <haxe/ds/IntMap.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObject
#include <openfl/display/DisplayObject.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObjectContainer
#include <openfl/display/DisplayObjectContainer.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_display_InteractiveObject
#include <openfl/display/InteractiveObject.h>
#endif
#ifndef INCLUDED_openfl_display_Sprite
#include <openfl/display/Sprite.h>
#endif
#ifndef INCLUDED_openfl_events_EventDispatcher
#include <openfl/events/EventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_events_IEventDispatcher
#include <openfl/events/IEventDispatcher.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_f77237052cf31132_11_new,"HUD","new",0xf45a2509,"HUD.new","HUD.hx",11,0xe7d70e87)
HX_LOCAL_STACK_FRAME(_hx_pos_f77237052cf31132_74_update,"HUD","update",0x5060c100,"HUD.update","HUD.hx",74,0xe7d70e87)
HX_LOCAL_STACK_FRAME(_hx_pos_f77237052cf31132_91_drawTimeUntilNextWave,"HUD","drawTimeUntilNextWave",0xeb0a1102,"HUD.drawTimeUntilNextWave","HUD.hx",91,0xe7d70e87)
HX_LOCAL_STACK_FRAME(_hx_pos_f77237052cf31132_100_drawInventorySpaces,"HUD","drawInventorySpaces",0xf1c25fae,"HUD.drawInventorySpaces","HUD.hx",100,0xe7d70e87)
HX_LOCAL_STACK_FRAME(_hx_pos_f77237052cf31132_114_updateInventory,"HUD","updateInventory",0xb288757c,"HUD.updateInventory","HUD.hx",114,0xe7d70e87)
HX_LOCAL_STACK_FRAME(_hx_pos_f77237052cf31132_212_drawStore,"HUD","drawStore",0x874a02a6,"HUD.drawStore","HUD.hx",212,0xe7d70e87)
HX_LOCAL_STACK_FRAME(_hx_pos_f77237052cf31132_142_drawStore,"HUD","drawStore",0x874a02a6,"HUD.drawStore","HUD.hx",142,0xe7d70e87)
HX_LOCAL_STACK_FRAME(_hx_pos_f77237052cf31132_145_drawStore,"HUD","drawStore",0x874a02a6,"HUD.drawStore","HUD.hx",145,0xe7d70e87)
HX_LOCAL_STACK_FRAME(_hx_pos_f77237052cf31132_153_drawStore,"HUD","drawStore",0x874a02a6,"HUD.drawStore","HUD.hx",153,0xe7d70e87)
HX_LOCAL_STACK_FRAME(_hx_pos_f77237052cf31132_195_drawStore,"HUD","drawStore",0x874a02a6,"HUD.drawStore","HUD.hx",195,0xe7d70e87)
HX_LOCAL_STACK_FRAME(_hx_pos_f77237052cf31132_218_buyItem,"HUD","buyItem",0xf5862ca2,"HUD.buyItem","HUD.hx",218,0xe7d70e87)

void HUD_obj::__construct( ::Survivor survivor){
            	HX_GC_STACKFRAME(&_hx_pos_f77237052cf31132_11_new)
HXLINE(  41)		 ::haxe::ds::IntMap _g =  ::haxe::ds::IntMap_obj::__alloc( HX_CTX );
HXDLIN(  41)		_g->set(1,100);
HXDLIN(  41)		this->_itemQtdToBuyMap = _g;
HXLINE(  37)		 ::haxe::ds::IntMap _g1 =  ::haxe::ds::IntMap_obj::__alloc( HX_CTX );
HXDLIN(  37)		_g1->set(0,HX_("assets/images/weapons/Tokarev_TT-33.png",58,94,51,61));
HXDLIN(  37)		_g1->set(1,HX_("assets/images/weapons/StG_44.png",57,33,b1,f3));
HXDLIN(  37)		this->_itemSpriteMap = _g1;
HXLINE(  34)		 ::haxe::ds::IntMap _g2 =  ::haxe::ds::IntMap_obj::__alloc( HX_CTX );
HXDLIN(  34)		_g2->set(1,((Float)10.0));
HXDLIN(  34)		this->_storePriceMap = _g2;
HXLINE(  33)		this->_isItemStoreVisible = false;
HXLINE(  32)		this->_itemStore =  ::flixel::group::FlxTypedGroup_obj::__alloc( HX_CTX ,null());
HXLINE(  29)		this->_inventoryNumberTextList = ::Array_obj< ::Dynamic>::__new();
HXLINE(  28)		this->_inventoryRenderedItems = ::Array_obj< int >::__new();
HXLINE(  27)		this->_inventoryItemSpritePadding = 8;
HXLINE(  25)		this->inventorySpaces = 5;
HXLINE(  24)		this->inventorySpaceSquareSize = 32;
HXLINE(  21)		this->drawStyle =  ::Dynamic(hx::Anon_obj::Create(1)
            			->setFixed(0,HX_("smoothing",74,d5,e1,95),true));
HXLINE(  20)		this->lineStyle =  ::Dynamic(hx::Anon_obj::Create(2)
            			->setFixed(0,HX_("color",63,71,5c,4a),-8355712)
            			->setFixed(1,HX_("thickness",74,f1,66,5a),1));
HXLINE(  46)		super::__construct(null());
HXLINE(  48)		this->_survivor = survivor;
HXLINE(  50)		this->_health =  ::flixel::text::FlxText_obj::__alloc( HX_CTX ,5,5,0,HX_("Health: ",62,76,08,c3),16,null());
HXLINE(  51)		Float _hx_tmp = this->_health->y;
HXDLIN(  51)		this->_ammoForCurrentWeapon =  ::flixel::text::FlxText_obj::__alloc( HX_CTX ,5,((_hx_tmp + this->_health->get_height()) + 8),0,HX_("Ammo: ",94,5d,40,08),16,null());
HXLINE(  52)		Float _hx_tmp1 = this->_ammoForCurrentWeapon->y;
HXDLIN(  52)		this->_money =  ::flixel::text::FlxText_obj::__alloc( HX_CTX ,5,((_hx_tmp1 + this->_ammoForCurrentWeapon->get_height()) + 8),0,HX_("$0",8c,1f,00,00),16,null());
HXLINE(  54)		this->_wave =  ::flixel::text::FlxText_obj::__alloc( HX_CTX ,0,5,0,HX_("Wave A",3a,96,36,f1),16,null());
HXLINE(  55)		 ::flixel::text::FlxText _hx_tmp2 = this->_wave;
HXDLIN(  55)		int _hx_tmp3 = ::flixel::FlxG_obj::width;
HXDLIN(  55)		_hx_tmp2->set_x(((( (Float)(_hx_tmp3) ) - this->_wave->get_width()) - ( (Float)(5) )));
HXLINE(  57)		this->_timeUntilNextWave =  ::flixel::text::FlxText_obj::__alloc( HX_CTX ,0,0,0,HX_("Next wave in ",61,4b,7b,dc),16,null());
HXLINE(  58)		 ::flixel::text::FlxText _hx_tmp4 = this->_timeUntilNextWave;
HXDLIN(  58)		Float _hx_tmp5 = (( (Float)(::flixel::FlxG_obj::width) ) / ( (Float)(2) ));
HXDLIN(  58)		_hx_tmp4->set_x((_hx_tmp5 - (this->_timeUntilNextWave->get_width() / ( (Float)(2) ))));
HXLINE(  59)		 ::flixel::text::FlxText _hx_tmp6 = this->_timeUntilNextWave;
HXDLIN(  59)		int _hx_tmp7 = ::flixel::FlxG_obj::height;
HXDLIN(  59)		_hx_tmp6->set_y(((( (Float)(_hx_tmp7) ) - this->_timeUntilNextWave->get_height()) - ( (Float)(8) )));
HXLINE(  60)		this->_timeUntilNextWave->kill();
HXLINE(  63)		this->inventoryBarTotalWidth = (this->inventorySpaceSquareSize * this->inventorySpaces);
HXLINE(  64)		this->drawInventorySpaces();
HXLINE(  65)		this->updateInventory();
HXLINE(  67)		this->add(this->_health);
HXLINE(  68)		this->add(this->_ammoForCurrentWeapon);
HXLINE(  69)		this->add(this->_money);
HXLINE(  70)		this->add(this->_wave);
HXLINE(  71)		this->add(this->_timeUntilNextWave);
            	}

Dynamic HUD_obj::__CreateEmpty() { return new HUD_obj; }

void *HUD_obj::_hx_vtable = 0;

Dynamic HUD_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< HUD_obj > _hx_result = new HUD_obj();
	_hx_result->__construct(inArgs[0]);
	return _hx_result;
}

bool HUD_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x25a685e0) {
		if (inClassId<=(int)0x0036ec97) {
			return inClassId==(int)0x00000001 || inClassId==(int)0x0036ec97;
		} else {
			return inClassId==(int)0x25a685e0;
		}
	} else {
		return inClassId==(int)0x3634c52c;
	}
}

void HUD_obj::update(Float elapsed){
            	HX_STACKFRAME(&_hx_pos_f77237052cf31132_74_update)
HXLINE(  75)		 ::PlayState s = ( ( ::PlayState)(::flixel::FlxG_obj::game->_state) );
HXLINE(  76)		this->_health->set_text((HX_("Health: ",62,76,08,c3) + s->playerHealth));
HXLINE(  77)		this->_money->set_text((HX_("$",24,00,00,00) + s->playerMoney));
HXLINE(  78)		this->_wave->set_text((HX_("Wave ",27,0c,54,58) + (s->currentWave + 1)));
HXLINE(  80)		 ::Dynamic ammoForCurrentWeapon;
HXDLIN(  80)		if (hx::IsNull( this->_survivor->_bulletsMap->get(::PlayState_obj::currentInventorySelectedItem) )) {
HXLINE(  80)			ammoForCurrentWeapon = 0;
            		}
            		else {
HXLINE(  80)			ammoForCurrentWeapon = this->_survivor->_bulletsMap->get(::PlayState_obj::currentInventorySelectedItem);
            		}
HXLINE(  81)		this->_ammoForCurrentWeapon->set_text((HX_("Ammo: ",94,5d,40,08) + ammoForCurrentWeapon));
HXLINE(  83)		this->drawTimeUntilNextWave(s);
HXLINE(  85)		 ::flixel::input::keyboard::FlxKeyList _this = ( ( ::flixel::input::keyboard::FlxKeyList)(::flixel::FlxG_obj::keys->justPressed) );
HXDLIN(  85)		if (_this->keyManager->checkStatus(66,_this->status)) {
HXLINE(  85)			this->drawStore();
            		}
HXLINE(  87)		this->super::update(elapsed);
            	}


void HUD_obj::drawTimeUntilNextWave( ::PlayState s){
            	HX_STACKFRAME(&_hx_pos_f77237052cf31132_91_drawTimeUntilNextWave)
HXDLIN(  91)		if ((s->secondsRemainingUntilNextWave > 0)) {
HXLINE(  92)			this->_timeUntilNextWave->revive();
HXLINE(  93)			this->_timeUntilNextWave->set_text((HX_("Next wave in ",61,4b,7b,dc) + s->secondsRemainingUntilNextWave));
            		}
            		else {
HXLINE(  95)			this->_timeUntilNextWave->kill();
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(HUD_obj,drawTimeUntilNextWave,(void))

void HUD_obj::drawInventorySpaces(){
            	HX_GC_STACKFRAME(&_hx_pos_f77237052cf31132_100_drawInventorySpaces)
HXDLIN( 100)		int _g = 0;
HXDLIN( 100)		int _g1 = this->inventorySpaces;
HXDLIN( 100)		while((_g < _g1)){
HXDLIN( 100)			_g = (_g + 1);
HXDLIN( 100)			int i = (_g - 1);
HXLINE( 101)			Float inventorySpaceX = (((( (Float)(::flixel::FlxG_obj::width) ) / ( (Float)(2) )) - (( (Float)(this->inventoryBarTotalWidth) ) / ( (Float)(2) ))) + (i * this->inventorySpaceSquareSize));
HXLINE( 102)			int inventorySpaceY = 4;
HXLINE( 104)			 ::flixel::FlxSprite _inventoryItemSpace =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,null(),null(),null())->makeGraphic(::flixel::FlxG_obj::width,::flixel::FlxG_obj::height,0,true,null());
HXLINE( 105)			::flixel::util::FlxSpriteUtil_obj::drawRect(_inventoryItemSpace,inventorySpaceX,( (Float)(inventorySpaceY) ),( (Float)(this->inventorySpaceSquareSize) ),( (Float)(this->inventorySpaceSquareSize) ),0,this->lineStyle,null());
HXLINE( 106)			this->add(_inventoryItemSpace);
HXLINE( 108)			Float _inventoryNumberText = ((inventorySpaceX + this->inventorySpaceSquareSize) - ( (Float)(12) ));
HXDLIN( 108)			int _inventoryNumberText1 = (this->inventorySpaceSquareSize - 10);
HXDLIN( 108)			 ::flixel::text::FlxText _inventoryNumberText2 =  ::flixel::text::FlxText_obj::__alloc( HX_CTX ,_inventoryNumberText,_inventoryNumberText1,0,::Std_obj::string((i + 1)),8,null());
HXLINE( 109)			this->add(_inventoryNumberText2);
HXLINE( 110)			this->_inventoryNumberTextList->push(_inventoryNumberText2);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(HUD_obj,drawInventorySpaces,(void))

void HUD_obj::updateInventory(){
            	HX_GC_STACKFRAME(&_hx_pos_f77237052cf31132_114_updateInventory)
HXLINE( 116)		{
HXLINE( 116)			int _g = 0;
HXDLIN( 116)			::Array< int > _g1 = ::PlayState_obj::inventoryItemsList;
HXDLIN( 116)			while((_g < _g1->length)){
HXLINE( 116)				int item = _g1->__get(_g);
HXDLIN( 116)				_g = (_g + 1);
HXLINE( 117)				if ((this->_inventoryRenderedItems->indexOf(item,null()) < 0)) {
HXLINE( 118)					Float xPositionToRenderItem = (((( (Float)(::flixel::FlxG_obj::width) ) / ( (Float)(2) )) - (( (Float)(this->inventoryBarTotalWidth) ) / ( (Float)(2) ))) + (this->inventorySpaceSquareSize * this->_inventoryRenderedItems->length));
HXLINE( 120)					 ::flixel::FlxSprite s =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,xPositionToRenderItem,((( (Float)(this->inventorySpaceSquareSize) ) / ( (Float)(2) )) - ( (Float)(4) )),null());
HXLINE( 121)					s->loadGraphic(this->_itemSpriteMap->get(item),false,null(),null(),null(),null());
HXLINE( 123)					s->setGraphicSize(32,null());
HXLINE( 124)					s->updateHitbox();
HXLINE( 125)					::flixel::util::FlxSpriteUtil_obj::updateSpriteGraphic(s,null());
HXLINE( 126)					s->set_angle(( (Float)(-32) ));
HXLINE( 127)					s->set_x((((( (Float)(::flixel::FlxG_obj::width) ) / ( (Float)(2) )) - (( (Float)(this->inventoryBarTotalWidth) ) / ( (Float)(2) ))) + (this->inventorySpaceSquareSize * this->_inventoryRenderedItems->length)));
HXLINE( 128)					this->add(s);
HXLINE( 129)					this->_inventoryRenderedItems->push(item);
            				}
            			}
            		}
HXLINE( 134)		this->_inventoryNumberTextList->__get(::PlayState_obj::currentInventorySelectedItem).StaticCast<  ::flixel::text::FlxText >()->set_color(-29696);
HXLINE( 135)		{
HXLINE( 135)			int _g2 = 0;
HXDLIN( 135)			int _g3 = this->inventorySpaces;
HXDLIN( 135)			while((_g2 < _g3)){
HXLINE( 135)				_g2 = (_g2 + 1);
HXDLIN( 135)				int i = (_g2 - 1);
HXLINE( 136)				if ((i != ::PlayState_obj::currentInventorySelectedItem)) {
HXLINE( 137)					this->_inventoryNumberTextList->__get(i).StaticCast<  ::flixel::text::FlxText >()->set_color(-4408132);
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(HUD_obj,updateInventory,(void))

void HUD_obj::drawStore(){
            		HX_BEGIN_LOCAL_FUNC_S1(hx::LocalFunc,_hx_Closure_3, ::HUD,_gthis) HXARGC(1)
            		void _hx_run( ::flixel::FlxSprite s2){
            			HX_GC_STACKFRAME(&_hx_pos_f77237052cf31132_212_drawStore)
HXLINE( 212)			_gthis->add(s2).StaticCast<  ::flixel::FlxSprite >();
            		}
            		HX_END_LOCAL_FUNC1((void))

            	HX_GC_STACKFRAME(&_hx_pos_f77237052cf31132_142_drawStore)
HXDLIN( 142)		 ::HUD _gthis = hx::ObjectPtr<OBJ_>(this);
HXLINE( 143)		if (this->_isItemStoreVisible) {
            			HX_BEGIN_LOCAL_FUNC_S1(hx::LocalFunc,_hx_Closure_0, ::HUD,_gthis) HXARGC(1)
            			void _hx_run( ::flixel::FlxSprite s){
            				HX_STACKFRAME(&_hx_pos_f77237052cf31132_145_drawStore)
HXLINE( 145)				_gthis->remove(s,null()).StaticCast<  ::flixel::FlxSprite >();
            			}
            			HX_END_LOCAL_FUNC1((void))

HXLINE( 144)			this->_itemStore->forEach( ::Dynamic(new _hx_Closure_0(_gthis)),false);
HXLINE( 147)			this->_isItemStoreVisible = false;
HXLINE( 148)			return;
            		}
HXLINE( 151)		if ((this->_itemStore->length > 0)) {
            			HX_BEGIN_LOCAL_FUNC_S1(hx::LocalFunc,_hx_Closure_1, ::HUD,_gthis) HXARGC(1)
            			void _hx_run( ::flixel::FlxSprite s1){
            				HX_STACKFRAME(&_hx_pos_f77237052cf31132_153_drawStore)
HXLINE( 153)				_gthis->add(s1).StaticCast<  ::flixel::FlxSprite >();
            			}
            			HX_END_LOCAL_FUNC1((void))

HXLINE( 152)			this->_itemStore->forEach( ::Dynamic(new _hx_Closure_1(_gthis)),false);
HXLINE( 155)			this->_isItemStoreVisible = true;
HXLINE( 156)			return;
            		}
HXLINE( 159)		int itemStoreWidth = (::flixel::FlxG_obj::width - 128);
HXLINE( 160)		int itemStoreHeight = (::flixel::FlxG_obj::height - 128);
HXLINE( 161)		int itemStoreStartX = 64;
HXLINE( 162)		int itemStoreStartY = 64;
HXLINE( 163)		int itemStoreSpaceSize = 128;
HXLINE( 164)		int itemStoreSpacePadding = 24;
HXLINE( 166)		 ::flixel::FlxSprite squareContainer =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,null(),null(),null())->makeGraphic(::flixel::FlxG_obj::width,::flixel::FlxG_obj::height,0,true,null());
HXLINE( 167)		::flixel::util::FlxSpriteUtil_obj::drawRect(squareContainer,( (Float)(itemStoreStartX) ),( (Float)(itemStoreStartY) ),( (Float)(itemStoreWidth) ),( (Float)(itemStoreHeight) ),-264422083,this->lineStyle,null());
HXLINE( 169)		 ::flixel::text::FlxText storeTitle =  ::flixel::text::FlxText_obj::__alloc( HX_CTX ,5,5,0,HX_("Item store",34,f9,ab,ff),16,null());
HXLINE( 170)		storeTitle->set_x((( (Float)(itemStoreWidth) ) / ( (Float)(2) )));
HXLINE( 171)		storeTitle->set_y(( (Float)(72) ));
HXLINE( 174)		this->_itemStore->add(squareContainer).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 175)		this->_itemStore->add(storeTitle).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 177)		int aux = 0;
HXLINE( 178)		{
HXLINE( 178)			 ::Dynamic itemKey = this->_storePriceMap->keys();
HXDLIN( 178)			while(( (bool)(itemKey->__Field(HX_("hasNext",6d,a5,46,18),hx::paccDynamic)()) )){
            				HX_BEGIN_LOCAL_FUNC_S2(hx::LocalFunc,_hx_Closure_2, ::HUD,_gthis,int,itemKey1) HXARGC(0)
            				void _hx_run(){
            					HX_GC_STACKFRAME(&_hx_pos_f77237052cf31132_195_drawStore)
HXLINE( 195)					_gthis->buyItem(itemKey1);
            				}
            				HX_END_LOCAL_FUNC0((void))

HXLINE( 178)				int itemKey1 = ( (int)(itemKey->__Field(HX_("next",f3,84,02,49),hx::paccDynamic)()) );
HXLINE( 179)				int itemX = ((itemStoreStartX + (aux * itemStoreSpaceSize)) + itemStoreSpacePadding);
HXLINE( 180)				Float itemY = ((itemStoreStartY + storeTitle->get_height()) + itemStoreSpacePadding);
HXLINE( 182)				 ::flixel::FlxSprite itemSpace =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,null(),null(),null())->makeGraphic(::flixel::FlxG_obj::width,::flixel::FlxG_obj::height,0,true,null());
HXLINE( 183)				::flixel::util::FlxSpriteUtil_obj::drawRect(itemSpace,( (Float)(itemX) ),itemY,( (Float)(itemStoreSpaceSize) ),( (Float)(itemStoreSpaceSize) ),0,this->lineStyle,null());
HXLINE( 184)				this->_itemStore->add(itemSpace).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 186)				 ::flixel::FlxSprite itemToSell =  ::flixel::FlxSprite_obj::__alloc( HX_CTX ,null(),null(),null());
HXLINE( 187)				itemToSell->loadGraphic(this->_itemSpriteMap->get(itemKey1),false,null(),null(),null(),null());
HXLINE( 188)				itemToSell->setGraphicSize((itemStoreSpaceSize - itemStoreSpacePadding),null());
HXLINE( 189)				itemToSell->set_angle(( (Float)(-24) ));
HXLINE( 190)				itemToSell->set_x((((( (Float)(itemStoreSpaceSize) ) / ( (Float)(2) )) + itemToSell->get_width()) - ( (Float)(8) )));
HXLINE( 191)				itemToSell->set_y((itemY + 32));
HXLINE( 192)				this->_itemStore->add(itemToSell).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 194)				 ::flixel::ui::FlxButton btnBuy =  ::flixel::ui::FlxButton_obj::__alloc( HX_CTX ,0,0,HX_("",00,00,00,00), ::Dynamic(new _hx_Closure_2(_gthis,itemKey1)));
HXLINE( 197)				if (hx::IsNull( btnBuy->label )) {
HXLINE( 197)					btnBuy->set_label( ::flixel::text::FlxText_obj::__alloc( HX_CTX ,(btnBuy->x + btnBuy->labelOffsets->__get(0).StaticCast<  ::flixel::math::FlxPoint >()->x),(btnBuy->y + btnBuy->labelOffsets->__get(0).StaticCast<  ::flixel::math::FlxPoint >()->y),80,HX_("Buy!",3b,46,f9,2b),null(),null()));
HXDLIN( 197)					btnBuy->label->setFormat(null(),8,3355443,HX_("center",d5,25,db,05),null(),null(),null());
HXDLIN( 197)					btnBuy->label->set_alpha(btnBuy->labelAlphas->__get(btnBuy->status));
HXDLIN( 197)					btnBuy->label->drawFrame(true);
            				}
            				else {
HXLINE( 197)					btnBuy->label->set_text(HX_("Buy!",3b,46,f9,2b));
            				}
HXLINE( 198)				btnBuy->set_x((((( (Float)(itemStoreSpaceSize) ) / ( (Float)(2) )) + (btnBuy->get_width() / ( (Float)(2) ))) + 10));
HXLINE( 199)				btnBuy->set_y((itemToSell->y + 64));
HXLINE( 200)				this->_itemStore->add(btnBuy).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 202)				 ::flixel::text::FlxText priceText =  ::flixel::text::FlxText_obj::__alloc( HX_CTX ,null(),null(),null(),null(),null(),null());
HXLINE( 203)				priceText->set_text((HX_("$",24,00,00,00) + ::Std_obj::string(this->_storePriceMap->get(itemKey1))));
HXLINE( 204)				priceText->set_x(((itemX + (( (Float)(itemStoreSpaceSize) ) / ( (Float)(2) ))) - (priceText->get_width() / ( (Float)(2) ))));
HXLINE( 205)				priceText->set_y((btnBuy->y - ( (Float)(16) )));
HXLINE( 206)				this->_itemStore->add(priceText).StaticCast<  ::flixel::FlxSprite >();
HXLINE( 208)				aux = (aux + 1);
            			}
            		}
HXLINE( 211)		this->_itemStore->forEach( ::Dynamic(new _hx_Closure_3(_gthis)),false);
HXLINE( 215)		this->_isItemStoreVisible = true;
            	}


HX_DEFINE_DYNAMIC_FUNC0(HUD_obj,drawStore,(void))

void HUD_obj::buyItem(int itemId){
            	HX_STACKFRAME(&_hx_pos_f77237052cf31132_218_buyItem)
HXLINE( 219)		 ::Dynamic itemPrice = this->_storePriceMap->get(itemId);
HXLINE( 220)		if (((this->_survivor->money - ( (Float)(itemPrice) )) >= 0)) {
HXLINE( 221)			 ::Survivor _hx_tmp = this->_survivor;
HXDLIN( 221)			_hx_tmp->money = (_hx_tmp->money - ( (Float)(itemPrice) ));
HXLINE( 222)			::PlayState_obj::inventoryItemsList->push(itemId);
HXLINE( 224)			 ::Dynamic qtdToBuy;
HXDLIN( 224)			if (hx::IsNull( this->_survivor->_bulletsMap->get(itemId) )) {
HXLINE( 224)				qtdToBuy = this->_itemQtdToBuyMap->get(itemId);
            			}
            			else {
HXLINE( 224)				 ::Dynamic qtdToBuy1 = this->_itemQtdToBuyMap->get(itemId);
HXDLIN( 224)				qtdToBuy = (qtdToBuy1 + this->_survivor->_bulletsMap->get(itemId));
            			}
HXLINE( 225)			this->_survivor->_bulletsMap->set(itemId,qtdToBuy);
HXLINE( 227)			this->updateInventory();
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(HUD_obj,buyItem,(void))


hx::ObjectPtr< HUD_obj > HUD_obj::__new( ::Survivor survivor) {
	hx::ObjectPtr< HUD_obj > __this = new HUD_obj();
	__this->__construct(survivor);
	return __this;
}

hx::ObjectPtr< HUD_obj > HUD_obj::__alloc(hx::Ctx *_hx_ctx, ::Survivor survivor) {
	HUD_obj *__this = (HUD_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(HUD_obj), true, "HUD"));
	*(void **)__this = HUD_obj::_hx_vtable;
	__this->__construct(survivor);
	return __this;
}

HUD_obj::HUD_obj()
{
}

void HUD_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(HUD);
	HX_MARK_MEMBER_NAME(_survivor,"_survivor");
	HX_MARK_MEMBER_NAME(_health,"_health");
	HX_MARK_MEMBER_NAME(_ammoForCurrentWeapon,"_ammoForCurrentWeapon");
	HX_MARK_MEMBER_NAME(_money,"_money");
	HX_MARK_MEMBER_NAME(_wave,"_wave");
	HX_MARK_MEMBER_NAME(_timeUntilNextWave,"_timeUntilNextWave");
	HX_MARK_MEMBER_NAME(lineStyle,"lineStyle");
	HX_MARK_MEMBER_NAME(drawStyle,"drawStyle");
	HX_MARK_MEMBER_NAME(inventorySpaceSquareSize,"inventorySpaceSquareSize");
	HX_MARK_MEMBER_NAME(inventorySpaces,"inventorySpaces");
	HX_MARK_MEMBER_NAME(inventoryBarTotalWidth,"inventoryBarTotalWidth");
	HX_MARK_MEMBER_NAME(_inventoryItemSpritePadding,"_inventoryItemSpritePadding");
	HX_MARK_MEMBER_NAME(_inventoryRenderedItems,"_inventoryRenderedItems");
	HX_MARK_MEMBER_NAME(_inventoryNumberTextList,"_inventoryNumberTextList");
	HX_MARK_MEMBER_NAME(_itemStore,"_itemStore");
	HX_MARK_MEMBER_NAME(_isItemStoreVisible,"_isItemStoreVisible");
	HX_MARK_MEMBER_NAME(_storePriceMap,"_storePriceMap");
	HX_MARK_MEMBER_NAME(_itemSpriteMap,"_itemSpriteMap");
	HX_MARK_MEMBER_NAME(_itemQtdToBuyMap,"_itemQtdToBuyMap");
	 ::flixel::group::FlxTypedGroup_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void HUD_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(_survivor,"_survivor");
	HX_VISIT_MEMBER_NAME(_health,"_health");
	HX_VISIT_MEMBER_NAME(_ammoForCurrentWeapon,"_ammoForCurrentWeapon");
	HX_VISIT_MEMBER_NAME(_money,"_money");
	HX_VISIT_MEMBER_NAME(_wave,"_wave");
	HX_VISIT_MEMBER_NAME(_timeUntilNextWave,"_timeUntilNextWave");
	HX_VISIT_MEMBER_NAME(lineStyle,"lineStyle");
	HX_VISIT_MEMBER_NAME(drawStyle,"drawStyle");
	HX_VISIT_MEMBER_NAME(inventorySpaceSquareSize,"inventorySpaceSquareSize");
	HX_VISIT_MEMBER_NAME(inventorySpaces,"inventorySpaces");
	HX_VISIT_MEMBER_NAME(inventoryBarTotalWidth,"inventoryBarTotalWidth");
	HX_VISIT_MEMBER_NAME(_inventoryItemSpritePadding,"_inventoryItemSpritePadding");
	HX_VISIT_MEMBER_NAME(_inventoryRenderedItems,"_inventoryRenderedItems");
	HX_VISIT_MEMBER_NAME(_inventoryNumberTextList,"_inventoryNumberTextList");
	HX_VISIT_MEMBER_NAME(_itemStore,"_itemStore");
	HX_VISIT_MEMBER_NAME(_isItemStoreVisible,"_isItemStoreVisible");
	HX_VISIT_MEMBER_NAME(_storePriceMap,"_storePriceMap");
	HX_VISIT_MEMBER_NAME(_itemSpriteMap,"_itemSpriteMap");
	HX_VISIT_MEMBER_NAME(_itemQtdToBuyMap,"_itemQtdToBuyMap");
	 ::flixel::group::FlxTypedGroup_obj::__Visit(HX_VISIT_ARG);
}

hx::Val HUD_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"_wave") ) { return hx::Val( _wave ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"_money") ) { return hx::Val( _money ); }
		if (HX_FIELD_EQ(inName,"update") ) { return hx::Val( update_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"_health") ) { return hx::Val( _health ); }
		if (HX_FIELD_EQ(inName,"buyItem") ) { return hx::Val( buyItem_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"_survivor") ) { return hx::Val( _survivor ); }
		if (HX_FIELD_EQ(inName,"lineStyle") ) { return hx::Val( lineStyle ); }
		if (HX_FIELD_EQ(inName,"drawStyle") ) { return hx::Val( drawStyle ); }
		if (HX_FIELD_EQ(inName,"drawStore") ) { return hx::Val( drawStore_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"_itemStore") ) { return hx::Val( _itemStore ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"_storePriceMap") ) { return hx::Val( _storePriceMap ); }
		if (HX_FIELD_EQ(inName,"_itemSpriteMap") ) { return hx::Val( _itemSpriteMap ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"inventorySpaces") ) { return hx::Val( inventorySpaces ); }
		if (HX_FIELD_EQ(inName,"updateInventory") ) { return hx::Val( updateInventory_dyn() ); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"_itemQtdToBuyMap") ) { return hx::Val( _itemQtdToBuyMap ); }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"_timeUntilNextWave") ) { return hx::Val( _timeUntilNextWave ); }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"_isItemStoreVisible") ) { return hx::Val( _isItemStoreVisible ); }
		if (HX_FIELD_EQ(inName,"drawInventorySpaces") ) { return hx::Val( drawInventorySpaces_dyn() ); }
		break;
	case 21:
		if (HX_FIELD_EQ(inName,"_ammoForCurrentWeapon") ) { return hx::Val( _ammoForCurrentWeapon ); }
		if (HX_FIELD_EQ(inName,"drawTimeUntilNextWave") ) { return hx::Val( drawTimeUntilNextWave_dyn() ); }
		break;
	case 22:
		if (HX_FIELD_EQ(inName,"inventoryBarTotalWidth") ) { return hx::Val( inventoryBarTotalWidth ); }
		break;
	case 23:
		if (HX_FIELD_EQ(inName,"_inventoryRenderedItems") ) { return hx::Val( _inventoryRenderedItems ); }
		break;
	case 24:
		if (HX_FIELD_EQ(inName,"inventorySpaceSquareSize") ) { return hx::Val( inventorySpaceSquareSize ); }
		if (HX_FIELD_EQ(inName,"_inventoryNumberTextList") ) { return hx::Val( _inventoryNumberTextList ); }
		break;
	case 27:
		if (HX_FIELD_EQ(inName,"_inventoryItemSpritePadding") ) { return hx::Val( _inventoryItemSpritePadding ); }
	}
	return super::__Field(inName,inCallProp);
}

hx::Val HUD_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"_wave") ) { _wave=inValue.Cast<  ::flixel::text::FlxText >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"_money") ) { _money=inValue.Cast<  ::flixel::text::FlxText >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"_health") ) { _health=inValue.Cast<  ::flixel::text::FlxText >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"_survivor") ) { _survivor=inValue.Cast<  ::Survivor >(); return inValue; }
		if (HX_FIELD_EQ(inName,"lineStyle") ) { lineStyle=inValue.Cast<  ::Dynamic >(); return inValue; }
		if (HX_FIELD_EQ(inName,"drawStyle") ) { drawStyle=inValue.Cast<  ::Dynamic >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"_itemStore") ) { _itemStore=inValue.Cast<  ::flixel::group::FlxTypedGroup >(); return inValue; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"_storePriceMap") ) { _storePriceMap=inValue.Cast<  ::haxe::ds::IntMap >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_itemSpriteMap") ) { _itemSpriteMap=inValue.Cast<  ::haxe::ds::IntMap >(); return inValue; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"inventorySpaces") ) { inventorySpaces=inValue.Cast< int >(); return inValue; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"_itemQtdToBuyMap") ) { _itemQtdToBuyMap=inValue.Cast<  ::haxe::ds::IntMap >(); return inValue; }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"_timeUntilNextWave") ) { _timeUntilNextWave=inValue.Cast<  ::flixel::text::FlxText >(); return inValue; }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"_isItemStoreVisible") ) { _isItemStoreVisible=inValue.Cast< bool >(); return inValue; }
		break;
	case 21:
		if (HX_FIELD_EQ(inName,"_ammoForCurrentWeapon") ) { _ammoForCurrentWeapon=inValue.Cast<  ::flixel::text::FlxText >(); return inValue; }
		break;
	case 22:
		if (HX_FIELD_EQ(inName,"inventoryBarTotalWidth") ) { inventoryBarTotalWidth=inValue.Cast< int >(); return inValue; }
		break;
	case 23:
		if (HX_FIELD_EQ(inName,"_inventoryRenderedItems") ) { _inventoryRenderedItems=inValue.Cast< ::Array< int > >(); return inValue; }
		break;
	case 24:
		if (HX_FIELD_EQ(inName,"inventorySpaceSquareSize") ) { inventorySpaceSquareSize=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_inventoryNumberTextList") ) { _inventoryNumberTextList=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 27:
		if (HX_FIELD_EQ(inName,"_inventoryItemSpritePadding") ) { _inventoryItemSpritePadding=inValue.Cast< int >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void HUD_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("_survivor",95,69,47,c6));
	outFields->push(HX_("_health",3b,3a,7d,6b));
	outFields->push(HX_("_ammoForCurrentWeapon",79,d8,b8,e6));
	outFields->push(HX_("_money",81,01,47,08));
	outFields->push(HX_("_wave",98,81,03,02));
	outFields->push(HX_("_timeUntilNextWave",7e,33,9e,98));
	outFields->push(HX_("lineStyle",9d,a8,18,cb));
	outFields->push(HX_("drawStyle",8d,da,28,4c));
	outFields->push(HX_("inventorySpaceSquareSize",28,c5,30,02));
	outFields->push(HX_("inventorySpaces",a9,68,f0,dd));
	outFields->push(HX_("inventoryBarTotalWidth",19,ef,7f,93));
	outFields->push(HX_("_inventoryItemSpritePadding",1c,50,09,ca));
	outFields->push(HX_("_inventoryRenderedItems",ee,bd,dd,45));
	outFields->push(HX_("_inventoryNumberTextList",d1,32,77,01));
	outFields->push(HX_("_itemStore",8f,f5,a3,df));
	outFields->push(HX_("_isItemStoreVisible",6d,cc,76,15));
	outFields->push(HX_("_storePriceMap",d5,78,d4,bc));
	outFields->push(HX_("_itemSpriteMap",45,c8,4f,54));
	outFields->push(HX_("_itemQtdToBuyMap",40,38,7d,ec));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static hx::StorageInfo HUD_obj_sMemberStorageInfo[] = {
	{hx::fsObject /*  ::Survivor */ ,(int)offsetof(HUD_obj,_survivor),HX_("_survivor",95,69,47,c6)},
	{hx::fsObject /*  ::flixel::text::FlxText */ ,(int)offsetof(HUD_obj,_health),HX_("_health",3b,3a,7d,6b)},
	{hx::fsObject /*  ::flixel::text::FlxText */ ,(int)offsetof(HUD_obj,_ammoForCurrentWeapon),HX_("_ammoForCurrentWeapon",79,d8,b8,e6)},
	{hx::fsObject /*  ::flixel::text::FlxText */ ,(int)offsetof(HUD_obj,_money),HX_("_money",81,01,47,08)},
	{hx::fsObject /*  ::flixel::text::FlxText */ ,(int)offsetof(HUD_obj,_wave),HX_("_wave",98,81,03,02)},
	{hx::fsObject /*  ::flixel::text::FlxText */ ,(int)offsetof(HUD_obj,_timeUntilNextWave),HX_("_timeUntilNextWave",7e,33,9e,98)},
	{hx::fsObject /*  ::Dynamic */ ,(int)offsetof(HUD_obj,lineStyle),HX_("lineStyle",9d,a8,18,cb)},
	{hx::fsObject /*  ::Dynamic */ ,(int)offsetof(HUD_obj,drawStyle),HX_("drawStyle",8d,da,28,4c)},
	{hx::fsInt,(int)offsetof(HUD_obj,inventorySpaceSquareSize),HX_("inventorySpaceSquareSize",28,c5,30,02)},
	{hx::fsInt,(int)offsetof(HUD_obj,inventorySpaces),HX_("inventorySpaces",a9,68,f0,dd)},
	{hx::fsInt,(int)offsetof(HUD_obj,inventoryBarTotalWidth),HX_("inventoryBarTotalWidth",19,ef,7f,93)},
	{hx::fsInt,(int)offsetof(HUD_obj,_inventoryItemSpritePadding),HX_("_inventoryItemSpritePadding",1c,50,09,ca)},
	{hx::fsObject /* ::Array< int > */ ,(int)offsetof(HUD_obj,_inventoryRenderedItems),HX_("_inventoryRenderedItems",ee,bd,dd,45)},
	{hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(HUD_obj,_inventoryNumberTextList),HX_("_inventoryNumberTextList",d1,32,77,01)},
	{hx::fsObject /*  ::flixel::group::FlxTypedGroup */ ,(int)offsetof(HUD_obj,_itemStore),HX_("_itemStore",8f,f5,a3,df)},
	{hx::fsBool,(int)offsetof(HUD_obj,_isItemStoreVisible),HX_("_isItemStoreVisible",6d,cc,76,15)},
	{hx::fsObject /*  ::haxe::ds::IntMap */ ,(int)offsetof(HUD_obj,_storePriceMap),HX_("_storePriceMap",d5,78,d4,bc)},
	{hx::fsObject /*  ::haxe::ds::IntMap */ ,(int)offsetof(HUD_obj,_itemSpriteMap),HX_("_itemSpriteMap",45,c8,4f,54)},
	{hx::fsObject /*  ::haxe::ds::IntMap */ ,(int)offsetof(HUD_obj,_itemQtdToBuyMap),HX_("_itemQtdToBuyMap",40,38,7d,ec)},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo *HUD_obj_sStaticStorageInfo = 0;
#endif

static ::String HUD_obj_sMemberFields[] = {
	HX_("_survivor",95,69,47,c6),
	HX_("_health",3b,3a,7d,6b),
	HX_("_ammoForCurrentWeapon",79,d8,b8,e6),
	HX_("_money",81,01,47,08),
	HX_("_wave",98,81,03,02),
	HX_("_timeUntilNextWave",7e,33,9e,98),
	HX_("lineStyle",9d,a8,18,cb),
	HX_("drawStyle",8d,da,28,4c),
	HX_("inventorySpaceSquareSize",28,c5,30,02),
	HX_("inventorySpaces",a9,68,f0,dd),
	HX_("inventoryBarTotalWidth",19,ef,7f,93),
	HX_("_inventoryItemSpritePadding",1c,50,09,ca),
	HX_("_inventoryRenderedItems",ee,bd,dd,45),
	HX_("_inventoryNumberTextList",d1,32,77,01),
	HX_("_itemStore",8f,f5,a3,df),
	HX_("_isItemStoreVisible",6d,cc,76,15),
	HX_("_storePriceMap",d5,78,d4,bc),
	HX_("_itemSpriteMap",45,c8,4f,54),
	HX_("_itemQtdToBuyMap",40,38,7d,ec),
	HX_("update",09,86,05,87),
	HX_("drawTimeUntilNextWave",19,5e,3c,dd),
	HX_("drawInventorySpaces",05,69,de,9d),
	HX_("updateInventory",53,47,41,98),
	HX_("drawStore",3d,49,21,4c),
	HX_("buyItem",79,cf,0d,8f),
	::String(null()) };

hx::Class HUD_obj::__mClass;

void HUD_obj::__register()
{
	HUD_obj _hx_dummy;
	HUD_obj::_hx_vtable = *(void **)&_hx_dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_("HUD",97,ec,36,00);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = hx::Class_obj::dupFunctions(HUD_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< HUD_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = HUD_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = HUD_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

