// Generated by Haxe 4.0.0-rc.2+77068e10c
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_flixel_math_FlxMatrix
#include <flixel/math/FlxMatrix.h>
#endif
#ifndef INCLUDED_flixel_math_FlxPoint
#include <flixel/math/FlxPoint.h>
#endif
#ifndef INCLUDED_flixel_math_FlxRect
#include <flixel/math/FlxRect.h>
#endif
#ifndef INCLUDED_flixel_util_FlxBitmapDataUtil
#include <flixel/util/FlxBitmapDataUtil.h>
#endif
#ifndef INCLUDED_flixel_util_FlxPool_flixel_math_FlxPoint
#include <flixel/util/FlxPool_flixel_math_FlxPoint.h>
#endif
#ifndef INCLUDED_flixel_util_FlxPool_flixel_math_FlxRect
#include <flixel/util/FlxPool_flixel_math_FlxRect.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPool
#include <flixel/util/IFlxPool.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPooled
#include <flixel/util/IFlxPooled.h>
#endif
#ifndef INCLUDED_flixel_util__FlxColor_FlxColor_Impl_
#include <flixel/util/_FlxColor/FlxColor_Impl_.h>
#endif
#ifndef INCLUDED_openfl_display_BitmapData
#include <openfl/display/BitmapData.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_geom_ColorTransform
#include <openfl/geom/ColorTransform.h>
#endif
#ifndef INCLUDED_openfl_geom_Matrix
#include <openfl/geom/Matrix.h>
#endif
#ifndef INCLUDED_openfl_geom_Point
#include <openfl/geom/Point.h>
#endif
#ifndef INCLUDED_openfl_geom_Rectangle
#include <openfl/geom/Rectangle.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_412bf34bd2ca21dd_32_merge,"flixel.util.FlxBitmapDataUtil","merge",0x21db12bd,"flixel.util.FlxBitmapDataUtil.merge","flixel/util/FlxBitmapDataUtil.hx",32,0xf477b24b)
HX_LOCAL_STACK_FRAME(_hx_pos_412bf34bd2ca21dd_149_mergeColorComponent,"flixel.util.FlxBitmapDataUtil","mergeColorComponent",0x5b71b277,"flixel.util.FlxBitmapDataUtil.mergeColorComponent","flixel/util/FlxBitmapDataUtil.hx",149,0xf477b24b)
HX_LOCAL_STACK_FRAME(_hx_pos_412bf34bd2ca21dd_164_compare,"flixel.util.FlxBitmapDataUtil","compare",0x217d53ea,"flixel.util.FlxBitmapDataUtil.compare","flixel/util/FlxBitmapDataUtil.hx",164,0xf477b24b)
HX_LOCAL_STACK_FRAME(_hx_pos_412bf34bd2ca21dd_232_getDiff,"flixel.util.FlxBitmapDataUtil","getDiff",0xb3004700,"flixel.util.FlxBitmapDataUtil.getDiff","flixel/util/FlxBitmapDataUtil.hx",232,0xf477b24b)
HX_LOCAL_STACK_FRAME(_hx_pos_412bf34bd2ca21dd_242_getMemorySize,"flixel.util.FlxBitmapDataUtil","getMemorySize",0x5bc2859d,"flixel.util.FlxBitmapDataUtil.getMemorySize","flixel/util/FlxBitmapDataUtil.hx",242,0xf477b24b)
HX_LOCAL_STACK_FRAME(_hx_pos_412bf34bd2ca21dd_257_replaceColor,"flixel.util.FlxBitmapDataUtil","replaceColor",0xbc41272a,"flixel.util.FlxBitmapDataUtil.replaceColor","flixel/util/FlxBitmapDataUtil.hx",257,0xf477b24b)
HX_LOCAL_STACK_FRAME(_hx_pos_412bf34bd2ca21dd_326_addSpacesAndBorders,"flixel.util.FlxBitmapDataUtil","addSpacesAndBorders",0xf8f1a643,"flixel.util.FlxBitmapDataUtil.addSpacesAndBorders","flixel/util/FlxBitmapDataUtil.hx",326,0xf477b24b)
HX_LOCAL_STACK_FRAME(_hx_pos_412bf34bd2ca21dd_409_copyBorderPixels,"flixel.util.FlxBitmapDataUtil","copyBorderPixels",0x739e20a9,"flixel.util.FlxBitmapDataUtil.copyBorderPixels","flixel/util/FlxBitmapDataUtil.hx",409,0xf477b24b)
HX_LOCAL_STACK_FRAME(_hx_pos_412bf34bd2ca21dd_469_generateRotations,"flixel.util.FlxBitmapDataUtil","generateRotations",0xe085af05,"flixel.util.FlxBitmapDataUtil.generateRotations","flixel/util/FlxBitmapDataUtil.hx",469,0xf477b24b)
HX_LOCAL_STACK_FRAME(_hx_pos_412bf34bd2ca21dd_17_boot,"flixel.util.FlxBitmapDataUtil","boot",0x2db7bbcd,"flixel.util.FlxBitmapDataUtil.boot","flixel/util/FlxBitmapDataUtil.hx",17,0xf477b24b)
namespace flixel{
namespace util{

void FlxBitmapDataUtil_obj::__construct() { }

Dynamic FlxBitmapDataUtil_obj::__CreateEmpty() { return new FlxBitmapDataUtil_obj; }

void *FlxBitmapDataUtil_obj::_hx_vtable = 0;

Dynamic FlxBitmapDataUtil_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< FlxBitmapDataUtil_obj > _hx_result = new FlxBitmapDataUtil_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool FlxBitmapDataUtil_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x1b702c2f;
}

 ::flixel::math::FlxMatrix FlxBitmapDataUtil_obj::matrix;

void FlxBitmapDataUtil_obj::merge( ::openfl::display::BitmapData sourceBitmapData, ::openfl::geom::Rectangle sourceRect, ::openfl::display::BitmapData destBitmapData, ::openfl::geom::Point destPoint,int redMultiplier,int greenMultiplier,int blueMultiplier,int alphaMultiplier){
            	HX_STACKFRAME(&_hx_pos_412bf34bd2ca21dd_32_merge)
HXLINE(  36)		bool _hx_tmp;
HXDLIN(  36)		bool _hx_tmp1;
HXDLIN(  36)		bool _hx_tmp2;
HXDLIN(  36)		bool _hx_tmp3;
HXDLIN(  36)		bool _hx_tmp4;
HXDLIN(  36)		if (!((destPoint->x >= destBitmapData->width))) {
HXLINE(  36)			_hx_tmp4 = (destPoint->y >= destBitmapData->height);
            		}
            		else {
HXLINE(  36)			_hx_tmp4 = true;
            		}
HXDLIN(  36)		if (!(_hx_tmp4)) {
HXLINE(  36)			_hx_tmp3 = (sourceRect->x >= sourceBitmapData->width);
            		}
            		else {
HXLINE(  36)			_hx_tmp3 = true;
            		}
HXDLIN(  36)		if (!(_hx_tmp3)) {
HXLINE(  36)			_hx_tmp2 = (sourceRect->y >= sourceBitmapData->height);
            		}
            		else {
HXLINE(  36)			_hx_tmp2 = true;
            		}
HXDLIN(  36)		if (!(_hx_tmp2)) {
HXLINE(  36)			_hx_tmp1 = ((sourceRect->x + sourceRect->width) <= 0);
            		}
            		else {
HXLINE(  36)			_hx_tmp1 = true;
            		}
HXDLIN(  36)		if (!(_hx_tmp1)) {
HXLINE(  36)			_hx_tmp = ((sourceRect->y + sourceRect->height) <= 0);
            		}
            		else {
HXLINE(  36)			_hx_tmp = true;
            		}
HXDLIN(  36)		if (_hx_tmp) {
HXLINE(  43)			return;
            		}
HXLINE(  47)		while(true){
HXLINE(  47)			bool _hx_tmp5;
HXDLIN(  47)			bool _hx_tmp6;
HXDLIN(  47)			bool _hx_tmp7;
HXDLIN(  47)			bool _hx_tmp8;
HXDLIN(  47)			bool _hx_tmp9;
HXDLIN(  47)			if (!(((sourceRect->x + sourceRect->width) > sourceBitmapData->width))) {
HXLINE(  47)				_hx_tmp9 = ((sourceRect->y + sourceRect->height) > sourceBitmapData->height);
            			}
            			else {
HXLINE(  47)				_hx_tmp9 = true;
            			}
HXDLIN(  47)			if (!(_hx_tmp9)) {
HXLINE(  47)				_hx_tmp8 = (sourceRect->x < 0);
            			}
            			else {
HXLINE(  47)				_hx_tmp8 = true;
            			}
HXDLIN(  47)			if (!(_hx_tmp8)) {
HXLINE(  47)				_hx_tmp7 = (sourceRect->y < 0);
            			}
            			else {
HXLINE(  47)				_hx_tmp7 = true;
            			}
HXDLIN(  47)			if (!(_hx_tmp7)) {
HXLINE(  47)				_hx_tmp6 = (destPoint->x < 0);
            			}
            			else {
HXLINE(  47)				_hx_tmp6 = true;
            			}
HXDLIN(  47)			if (!(_hx_tmp6)) {
HXLINE(  47)				_hx_tmp5 = (destPoint->y < 0);
            			}
            			else {
HXLINE(  47)				_hx_tmp5 = true;
            			}
HXDLIN(  47)			if (!(_hx_tmp5)) {
HXLINE(  47)				goto _hx_goto_0;
            			}
HXLINE(  54)			if (((sourceRect->x + sourceRect->width) > sourceBitmapData->width)) {
HXLINE(  54)				sourceRect->width = (( (Float)(sourceBitmapData->width) ) - sourceRect->x);
            			}
HXLINE(  55)			if (((sourceRect->y + sourceRect->height) > sourceBitmapData->height)) {
HXLINE(  55)				sourceRect->height = (( (Float)(sourceBitmapData->height) ) - sourceRect->y);
            			}
HXLINE(  57)			if ((sourceRect->x < 0)) {
HXLINE(  59)				destPoint->x = (destPoint->x - sourceRect->x);
HXLINE(  60)				sourceRect->width = (sourceRect->width + sourceRect->x);
HXLINE(  61)				sourceRect->x = ( (Float)(0) );
            			}
HXLINE(  64)			if ((sourceRect->y < 0)) {
HXLINE(  66)				destPoint->y = (destPoint->y - sourceRect->y);
HXLINE(  67)				sourceRect->height = (sourceRect->height + sourceRect->y);
HXLINE(  68)				sourceRect->y = ( (Float)(0) );
            			}
HXLINE(  71)			bool _hx_tmp10;
HXDLIN(  71)			if (!((destPoint->x >= destBitmapData->width))) {
HXLINE(  71)				_hx_tmp10 = (destPoint->y >= destBitmapData->height);
            			}
            			else {
HXLINE(  71)				_hx_tmp10 = true;
            			}
HXDLIN(  71)			if (_hx_tmp10) {
HXLINE(  71)				return;
            			}
HXLINE(  73)			if ((destPoint->x < 0)) {
HXLINE(  75)				sourceRect->x = (sourceRect->x - destPoint->x);
HXLINE(  76)				sourceRect->width = (sourceRect->width + destPoint->x);
HXLINE(  77)				destPoint->x = ( (Float)(0) );
            			}
HXLINE(  80)			if ((destPoint->y < 0)) {
HXLINE(  82)				sourceRect->y = (sourceRect->y - destPoint->y);
HXLINE(  83)				sourceRect->height = (sourceRect->height + destPoint->y);
HXLINE(  84)				destPoint->y = ( (Float)(0) );
            			}
            		}
            		_hx_goto_0:;
HXLINE(  88)		bool _hx_tmp11;
HXDLIN(  88)		if (!((sourceRect->width <= 0))) {
HXLINE(  88)			_hx_tmp11 = (sourceRect->height <= 0);
            		}
            		else {
HXLINE(  88)			_hx_tmp11 = true;
            		}
HXDLIN(  88)		if (_hx_tmp11) {
HXLINE(  88)			return;
            		}
HXLINE(  90)		int startSourceX = ::Math_obj::round(sourceRect->x);
HXLINE(  91)		int startSourceY = ::Math_obj::round(sourceRect->y);
HXLINE(  93)		int width = ::Math_obj::round(sourceRect->width);
HXLINE(  94)		int height = ::Math_obj::round(sourceRect->height);
HXLINE(  96)		int sourceX = startSourceX;
HXLINE(  97)		int sourceY = startSourceY;
HXLINE(  99)		int destX = ::Math_obj::round(destPoint->x);
HXLINE( 100)		int destY = ::Math_obj::round(destPoint->y);
HXLINE( 102)		int currX = destX;
HXLINE( 103)		int currY = destY;
HXLINE( 105)		int sourceColor;
HXLINE( 106)		int destColor;
HXLINE( 108)		int resultRed;
HXLINE( 109)		int resultGreen;
HXLINE( 110)		int resultBlue;
HXLINE( 111)		int resultAlpha;
HXLINE( 113)		int resultColor = 0;
HXLINE( 114)		destBitmapData->lock();
HXLINE( 117)		{
HXLINE( 117)			int _g = 0;
HXDLIN( 117)			int _g1 = width;
HXDLIN( 117)			while((_g < _g1)){
HXLINE( 117)				_g = (_g + 1);
HXDLIN( 117)				int i = (_g - 1);
HXLINE( 119)				{
HXLINE( 119)					int _g2 = 0;
HXDLIN( 119)					int _g11 = height;
HXDLIN( 119)					while((_g2 < _g11)){
HXLINE( 119)						_g2 = (_g2 + 1);
HXDLIN( 119)						int j = (_g2 - 1);
HXLINE( 121)						sourceX = (startSourceX + i);
HXLINE( 122)						sourceY = (startSourceY + j);
HXLINE( 124)						currX = (destX + i);
HXLINE( 125)						currY = (destY + j);
HXLINE( 127)						sourceColor = sourceBitmapData->getPixel32(sourceX,sourceY);
HXLINE( 128)						destColor = destBitmapData->getPixel32(currX,currY);
HXLINE( 131)						resultRed = ::Std_obj::_hx_int((( (Float)(((((sourceColor >> 16) & 255) * redMultiplier) + (((destColor >> 16) & 255) * (256 - redMultiplier)))) ) / ( (Float)(256) )));
HXLINE( 132)						resultGreen = ::Std_obj::_hx_int((( (Float)(((((sourceColor >> 8) & 255) * greenMultiplier) + (((destColor >> 8) & 255) * (256 - greenMultiplier)))) ) / ( (Float)(256) )));
HXLINE( 133)						resultBlue = ::Std_obj::_hx_int((( (Float)((((sourceColor & 255) * blueMultiplier) + ((destColor & 255) * (256 - blueMultiplier)))) ) / ( (Float)(256) )));
HXLINE( 134)						resultAlpha = ::Std_obj::_hx_int((( (Float)(((((sourceColor >> 24) & 255) * alphaMultiplier) + (((destColor >> 24) & 255) * (256 - alphaMultiplier)))) ) / ( (Float)(256) )));
HXLINE( 137)						int color = ::flixel::util::_FlxColor::FlxColor_Impl__obj::_new(null());
HXDLIN( 137)						{
HXLINE( 137)							color = (color & -16711681);
HXDLIN( 137)							int color1;
HXDLIN( 137)							if ((resultRed > 255)) {
HXLINE( 137)								color1 = 255;
            							}
            							else {
HXLINE( 137)								if ((resultRed < 0)) {
HXLINE( 137)									color1 = 0;
            								}
            								else {
HXLINE( 137)									color1 = resultRed;
            								}
            							}
HXDLIN( 137)							color = (color | (color1 << 16));
            						}
HXDLIN( 137)						{
HXLINE( 137)							color = (color & -65281);
HXDLIN( 137)							int color2;
HXDLIN( 137)							if ((resultGreen > 255)) {
HXLINE( 137)								color2 = 255;
            							}
            							else {
HXLINE( 137)								if ((resultGreen < 0)) {
HXLINE( 137)									color2 = 0;
            								}
            								else {
HXLINE( 137)									color2 = resultGreen;
            								}
            							}
HXDLIN( 137)							color = (color | (color2 << 8));
            						}
HXDLIN( 137)						{
HXLINE( 137)							color = (color & -256);
HXDLIN( 137)							int color3;
HXDLIN( 137)							if ((resultBlue > 255)) {
HXLINE( 137)								color3 = 255;
            							}
            							else {
HXLINE( 137)								if ((resultBlue < 0)) {
HXLINE( 137)									color3 = 0;
            								}
            								else {
HXLINE( 137)									color3 = resultBlue;
            								}
            							}
HXDLIN( 137)							color = (color | color3);
            						}
HXDLIN( 137)						{
HXLINE( 137)							color = (color & 16777215);
HXDLIN( 137)							int color4;
HXDLIN( 137)							if ((resultAlpha > 255)) {
HXLINE( 137)								color4 = 255;
            							}
            							else {
HXLINE( 137)								if ((resultAlpha < 0)) {
HXLINE( 137)									color4 = 0;
            								}
            								else {
HXLINE( 137)									color4 = resultAlpha;
            								}
            							}
HXDLIN( 137)							color = (color | (color4 << 24));
            						}
HXDLIN( 137)						resultColor = color;
HXLINE( 140)						destBitmapData->setPixel32(currX,currY,resultColor);
            					}
            				}
            			}
            		}
HXLINE( 143)		destBitmapData->unlock(null());
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC8(FlxBitmapDataUtil_obj,merge,(void))

int FlxBitmapDataUtil_obj::mergeColorComponent(int source,int dest,int multiplier){
            	HX_STACKFRAME(&_hx_pos_412bf34bd2ca21dd_149_mergeColorComponent)
HXDLIN( 149)		return ::Std_obj::_hx_int((( (Float)(((source * multiplier) + (dest * (256 - multiplier)))) ) / ( (Float)(256) )));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(FlxBitmapDataUtil_obj,mergeColorComponent,return )

 ::Dynamic FlxBitmapDataUtil_obj::compare( ::openfl::display::BitmapData Bitmap1, ::openfl::display::BitmapData Bitmap2){
            	HX_GC_STACKFRAME(&_hx_pos_412bf34bd2ca21dd_164_compare)
HXLINE( 168)		if (hx::IsEq( Bitmap1,Bitmap2 )) {
HXLINE( 170)			return 0;
            		}
HXLINE( 172)		if ((Bitmap1->width != Bitmap2->width)) {
HXLINE( 174)			return -3;
            		}
            		else {
HXLINE( 176)			if ((Bitmap1->height != Bitmap2->height)) {
HXLINE( 178)				return -4;
            			}
            			else {
HXLINE( 182)				int width = Bitmap1->width;
HXLINE( 183)				int height = Bitmap1->height;
HXLINE( 184)				 ::openfl::display::BitmapData result =  ::openfl::display::BitmapData_obj::__alloc( HX_CTX ,width,height,true,0);
HXLINE( 185)				bool identical = true;
HXLINE( 187)				{
HXLINE( 187)					int _g = 0;
HXDLIN( 187)					int _g1 = width;
HXDLIN( 187)					while((_g < _g1)){
HXLINE( 187)						_g = (_g + 1);
HXDLIN( 187)						int i = (_g - 1);
HXLINE( 189)						{
HXLINE( 189)							int _g2 = 0;
HXDLIN( 189)							int _g11 = height;
HXDLIN( 189)							while((_g2 < _g11)){
HXLINE( 189)								_g2 = (_g2 + 1);
HXDLIN( 189)								int j = (_g2 - 1);
HXLINE( 191)								int pixel1 = Bitmap1->getPixel32(i,j);
HXLINE( 192)								int pixel2 = Bitmap2->getPixel32(i,j);
HXLINE( 194)								if ((pixel1 != pixel2)) {
HXLINE( 196)									identical = false;
HXLINE( 198)									if (((pixel1 & 16777215) != (pixel2 & 16777215))) {
HXLINE( 201)										int diff = (((pixel1 >> 16) & 255) - ((pixel2 >> 16) & 255));
HXLINE( 200)										int Red;
HXLINE( 201)										if ((diff >= 0)) {
HXLINE( 200)											Red = diff;
            										}
            										else {
HXLINE( 200)											Red = (256 + diff);
            										}
HXLINE( 202)										int diff1 = (((pixel1 >> 8) & 255) - ((pixel2 >> 8) & 255));
HXLINE( 200)										int Green;
HXLINE( 202)										if ((diff1 >= 0)) {
HXLINE( 200)											Green = diff1;
            										}
            										else {
HXLINE( 200)											Green = (256 + diff1);
            										}
HXLINE( 203)										int diff2 = ((pixel1 & 255) - (pixel2 & 255));
HXLINE( 200)										int Blue;
HXLINE( 203)										if ((diff2 >= 0)) {
HXLINE( 200)											Blue = diff2;
            										}
            										else {
HXLINE( 200)											Blue = (256 + diff2);
            										}
HXDLIN( 200)										int Alpha = 255;
HXDLIN( 200)										int color = ::flixel::util::_FlxColor::FlxColor_Impl__obj::_new(null());
HXDLIN( 200)										{
HXLINE( 200)											color = (color & -16711681);
HXDLIN( 200)											int color1;
HXDLIN( 200)											if ((Red > 255)) {
HXLINE( 200)												color1 = 255;
            											}
            											else {
HXLINE( 200)												if ((Red < 0)) {
HXLINE( 200)													color1 = 0;
            												}
            												else {
HXLINE( 200)													color1 = Red;
            												}
            											}
HXDLIN( 200)											color = (color | (color1 << 16));
            										}
HXDLIN( 200)										{
HXLINE( 200)											color = (color & -65281);
HXDLIN( 200)											int color2;
HXDLIN( 200)											if ((Green > 255)) {
HXLINE( 200)												color2 = 255;
            											}
            											else {
HXLINE( 200)												if ((Green < 0)) {
HXLINE( 200)													color2 = 0;
            												}
            												else {
HXLINE( 200)													color2 = Green;
            												}
            											}
HXDLIN( 200)											color = (color | (color2 << 8));
            										}
HXDLIN( 200)										{
HXLINE( 200)											color = (color & -256);
HXDLIN( 200)											int color3;
HXDLIN( 200)											if ((Blue > 255)) {
HXLINE( 200)												color3 = 255;
            											}
            											else {
HXLINE( 200)												if ((Blue < 0)) {
HXLINE( 200)													color3 = 0;
            												}
            												else {
HXLINE( 200)													color3 = Blue;
            												}
            											}
HXDLIN( 200)											color = (color | color3);
            										}
HXDLIN( 200)										{
HXLINE( 200)											color = (color & 16777215);
HXDLIN( 200)											int color4;
HXDLIN( 200)											if ((Alpha > 255)) {
HXLINE( 200)												color4 = 255;
            											}
            											else {
HXLINE( 200)												if ((Alpha < 0)) {
HXLINE( 200)													color4 = 0;
            												}
            												else {
HXLINE( 200)													color4 = Alpha;
            												}
            											}
HXDLIN( 200)											color = (color | (color4 << 24));
            										}
HXDLIN( 200)										result->setPixel32(i,j,color);
            									}
            									else {
HXLINE( 208)										int alpha1 = ((pixel1 >> 24) & 255);
HXLINE( 209)										int alpha2 = ((pixel2 >> 24) & 255);
HXLINE( 211)										if ((alpha1 != alpha2)) {
HXLINE( 214)											int diff3 = (alpha1 - alpha2);
HXLINE( 213)											int Alpha1;
HXLINE( 214)											if ((diff3 >= 0)) {
HXLINE( 213)												Alpha1 = diff3;
            											}
            											else {
HXLINE( 213)												Alpha1 = (256 + diff3);
            											}
HXDLIN( 213)											int color5 = ::flixel::util::_FlxColor::FlxColor_Impl__obj::_new(null());
HXDLIN( 213)											{
HXLINE( 213)												color5 = (color5 & -16711681);
HXDLIN( 213)												color5 = (color5 | 16711680);
            											}
HXDLIN( 213)											{
HXLINE( 213)												color5 = (color5 & -65281);
HXDLIN( 213)												color5 = (color5 | 65280);
            											}
HXDLIN( 213)											{
HXLINE( 213)												color5 = (color5 & -256);
HXDLIN( 213)												color5 = (color5 | 255);
            											}
HXDLIN( 213)											{
HXLINE( 213)												color5 = (color5 & 16777215);
HXDLIN( 213)												int color6;
HXDLIN( 213)												if ((Alpha1 > 255)) {
HXLINE( 213)													color6 = 255;
            												}
            												else {
HXLINE( 213)													if ((Alpha1 < 0)) {
HXLINE( 213)														color6 = 0;
            													}
            													else {
HXLINE( 213)														color6 = Alpha1;
            													}
            												}
HXDLIN( 213)												color5 = (color5 | (color6 << 24));
            											}
HXDLIN( 213)											result->setPixel32(i,j,color5);
            										}
            									}
            								}
            							}
            						}
            					}
            				}
HXLINE( 221)				if (!(identical)) {
HXLINE( 223)					return result;
            				}
            			}
            		}
HXLINE( 227)		return 0;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(FlxBitmapDataUtil_obj,compare,return )

int FlxBitmapDataUtil_obj::getDiff(int value1,int value2){
            	HX_STACKFRAME(&_hx_pos_412bf34bd2ca21dd_232_getDiff)
HXLINE( 233)		int diff = (value1 - value2);
HXLINE( 234)		if ((diff >= 0)) {
HXLINE( 234)			return diff;
            		}
            		else {
HXLINE( 234)			return (256 + diff);
            		}
HXDLIN( 234)		return 0;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(FlxBitmapDataUtil_obj,getDiff,return )

Float FlxBitmapDataUtil_obj::getMemorySize( ::openfl::display::BitmapData bitmapData){
            	HX_STACKFRAME(&_hx_pos_412bf34bd2ca21dd_242_getMemorySize)
HXDLIN( 242)		return ( (Float)(((bitmapData->width * bitmapData->height) * 4)) );
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(FlxBitmapDataUtil_obj,getMemorySize,return )

::Array< ::Dynamic> FlxBitmapDataUtil_obj::replaceColor( ::openfl::display::BitmapData bitmapData,int color,int newColor,hx::Null< bool >  __o_fetchPositions, ::flixel::math::FlxRect rect){
            		bool fetchPositions = __o_fetchPositions.Default(false);
            	HX_STACKFRAME(&_hx_pos_412bf34bd2ca21dd_257_replaceColor)
HXLINE( 258)		::Array< ::Dynamic> positions = null();
HXLINE( 259)		if (fetchPositions) {
HXLINE( 261)			positions = ::Array_obj< ::Dynamic>::__new();
            		}
HXLINE( 264)		int startX = 0;
HXLINE( 265)		int startY = 0;
HXLINE( 266)		int columns = bitmapData->width;
HXLINE( 267)		int rows = bitmapData->height;
HXLINE( 269)		if (hx::IsNotNull( rect )) {
HXLINE( 271)			startX = ::Std_obj::_hx_int(rect->x);
HXLINE( 272)			startY = ::Std_obj::_hx_int(rect->y);
HXLINE( 273)			columns = ::Std_obj::_hx_int(rect->width);
HXLINE( 274)			rows = ::Std_obj::_hx_int(rect->height);
            		}
HXLINE( 277)		columns = ::Std_obj::_hx_int(::Math_obj::max(( (Float)(columns) ),( (Float)(bitmapData->width) )));
HXLINE( 278)		rows = ::Std_obj::_hx_int(::Math_obj::max(( (Float)(rows) ),( (Float)(bitmapData->height) )));
HXLINE( 280)		int row = 0;
HXLINE( 281)		int column = 0;
HXLINE( 282)		int x;
HXDLIN( 282)		int y;
HXLINE( 284)		bool changed = false;
HXLINE( 285)		bitmapData->lock();
HXLINE( 286)		while((row < rows)){
HXLINE( 288)			column = 0;
HXLINE( 289)			while((column < columns)){
HXLINE( 291)				x = (startX + column);
HXLINE( 292)				y = (startY + row);
HXLINE( 293)				if ((bitmapData->getPixel32(x,y) == color)) {
HXLINE( 295)					bitmapData->setPixel32(x,y,newColor);
HXLINE( 296)					changed = true;
HXLINE( 297)					if (fetchPositions) {
HXLINE( 299)						 ::flixel::math::FlxPoint point = ::flixel::math::FlxPoint_obj::_pool->get()->set(x,y);
HXDLIN( 299)						point->_inPool = false;
HXDLIN( 299)						positions->push(point);
            					}
            				}
HXLINE( 302)				column = (column + 1);
            			}
HXLINE( 304)			row = (row + 1);
            		}
HXLINE( 306)		bitmapData->unlock(null());
HXLINE( 308)		bool _hx_tmp;
HXDLIN( 308)		if (changed) {
HXLINE( 308)			_hx_tmp = hx::IsNull( positions );
            		}
            		else {
HXLINE( 308)			_hx_tmp = false;
            		}
HXDLIN( 308)		if (_hx_tmp) {
HXLINE( 310)			positions = ::Array_obj< ::Dynamic>::__new();
            		}
HXLINE( 313)		return positions;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC5(FlxBitmapDataUtil_obj,replaceColor,return )

 ::openfl::display::BitmapData FlxBitmapDataUtil_obj::addSpacesAndBorders( ::openfl::display::BitmapData bitmapData, ::flixel::math::FlxPoint frameSize, ::flixel::math::FlxPoint spacing, ::flixel::math::FlxPoint border, ::flixel::math::FlxRect region){
            	HX_GC_STACKFRAME(&_hx_pos_412bf34bd2ca21dd_326_addSpacesAndBorders)
HXLINE( 327)		if (hx::IsNull( region )) {
HXLINE( 329)			Float Width = ( (Float)(bitmapData->width) );
HXDLIN( 329)			Float Height = ( (Float)(bitmapData->height) );
HXDLIN( 329)			 ::flixel::math::FlxRect _this = ::flixel::math::FlxRect_obj::_pool->get();
HXDLIN( 329)			_this->x = ( (Float)(0) );
HXDLIN( 329)			_this->y = ( (Float)(0) );
HXDLIN( 329)			_this->width = Width;
HXDLIN( 329)			_this->height = Height;
HXDLIN( 329)			 ::flixel::math::FlxRect rect = _this;
HXDLIN( 329)			rect->_inPool = false;
HXDLIN( 329)			region = rect;
            		}
HXLINE( 332)		int frameWidth = ::Std_obj::_hx_int(region->width);
HXLINE( 333)		int frameHeight = ::Std_obj::_hx_int(region->height);
HXLINE( 335)		if (hx::IsNotNull( frameSize )) {
HXLINE( 337)			frameWidth = ::Std_obj::_hx_int(frameSize->x);
HXLINE( 338)			frameHeight = ::Std_obj::_hx_int(frameSize->y);
            		}
HXLINE( 341)		int numHorizontalFrames = ::Std_obj::_hx_int((region->width / ( (Float)(frameWidth) )));
HXLINE( 342)		int numVerticalFrames = ::Std_obj::_hx_int((region->height / ( (Float)(frameHeight) )));
HXLINE( 344)		int spaceX = 0;
HXLINE( 345)		int spaceY = 0;
HXLINE( 347)		if (hx::IsNotNull( spacing )) {
HXLINE( 349)			spaceX = ::Std_obj::_hx_int(spacing->x);
HXLINE( 350)			spaceY = ::Std_obj::_hx_int(spacing->y);
            		}
HXLINE( 353)		int borderX = 0;
HXLINE( 354)		int borderY = 0;
HXLINE( 356)		if (hx::IsNotNull( border )) {
HXLINE( 358)			borderX = ::Std_obj::_hx_int(border->x);
HXLINE( 359)			borderY = ::Std_obj::_hx_int(border->y);
            		}
HXLINE( 363)		int result = ::Std_obj::_hx_int(((region->width + ((numHorizontalFrames - 1) * spaceX)) + ((2 * numHorizontalFrames) * borderX)));
HXLINE( 362)		 ::openfl::display::BitmapData result1 =  ::openfl::display::BitmapData_obj::__alloc( HX_CTX ,result,::Std_obj::_hx_int(((region->height + ((numVerticalFrames - 1) * spaceY)) + ((2 * numVerticalFrames) * borderY))),true,0);
HXLINE( 368)		result1->lock();
HXLINE( 369)		 ::openfl::geom::Rectangle tempRect =  ::openfl::geom::Rectangle_obj::__alloc( HX_CTX ,0,0,frameWidth,frameHeight);
HXLINE( 370)		 ::openfl::geom::Point tempPoint =  ::openfl::geom::Point_obj::__alloc( HX_CTX ,null(),null());
HXLINE( 373)		{
HXLINE( 373)			int _g = 0;
HXDLIN( 373)			int _g1 = numHorizontalFrames;
HXDLIN( 373)			while((_g < _g1)){
HXLINE( 373)				_g = (_g + 1);
HXDLIN( 373)				int i = (_g - 1);
HXLINE( 375)				tempPoint->x = ( (Float)(((i * ((frameWidth + spaceX) + (2 * borderX))) + borderX)) );
HXLINE( 376)				tempRect->x = ((i * frameWidth) + region->x);
HXLINE( 378)				{
HXLINE( 378)					int _g2 = 0;
HXDLIN( 378)					int _g11 = numVerticalFrames;
HXDLIN( 378)					while((_g2 < _g11)){
HXLINE( 378)						_g2 = (_g2 + 1);
HXDLIN( 378)						int j = (_g2 - 1);
HXLINE( 380)						tempPoint->y = ( (Float)(((j * ((frameHeight + spaceY) + (2 * borderY))) + borderY)) );
HXLINE( 381)						tempRect->y = ((j * frameHeight) + region->y);
HXLINE( 382)						result1->copyPixels(bitmapData,tempRect,tempPoint,null(),null(),null());
            					}
            				}
            			}
            		}
HXLINE( 385)		result1->unlock(null());
HXLINE( 388)		::flixel::util::FlxBitmapDataUtil_obj::copyBorderPixels(result1,frameWidth,frameHeight,spaceX,spaceY,borderX,borderY,numHorizontalFrames,numVerticalFrames);
HXLINE( 389)		return result1;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC5(FlxBitmapDataUtil_obj,addSpacesAndBorders,return )

 ::openfl::display::BitmapData FlxBitmapDataUtil_obj::copyBorderPixels( ::openfl::display::BitmapData bitmapData,int frameWidth,int frameHeight,int spaceX,int spaceY,int borderX,int borderY,int horizontalFrames,int verticalFrames){
            	HX_GC_STACKFRAME(&_hx_pos_412bf34bd2ca21dd_409_copyBorderPixels)
HXLINE( 411)		 ::openfl::geom::Rectangle tempRect =  ::openfl::geom::Rectangle_obj::__alloc( HX_CTX ,0,0,1,bitmapData->height);
HXLINE( 412)		 ::openfl::geom::Point tempPoint =  ::openfl::geom::Point_obj::__alloc( HX_CTX ,null(),null());
HXLINE( 413)		bitmapData->lock();
HXLINE( 415)		{
HXLINE( 415)			int _g = 0;
HXDLIN( 415)			int _g1 = horizontalFrames;
HXDLIN( 415)			while((_g < _g1)){
HXLINE( 415)				_g = (_g + 1);
HXDLIN( 415)				int i = (_g - 1);
HXLINE( 417)				tempRect->x = ( (Float)(((i * ((frameWidth + (2 * borderX)) + spaceX)) + borderX)) );
HXLINE( 419)				{
HXLINE( 419)					int _g2 = 0;
HXDLIN( 419)					int _g11 = borderX;
HXDLIN( 419)					while((_g2 < _g11)){
HXLINE( 419)						_g2 = (_g2 + 1);
HXDLIN( 419)						int j = (_g2 - 1);
HXLINE( 421)						tempPoint->x = ((tempRect->x - ( (Float)(j) )) - ( (Float)(1) ));
HXLINE( 422)						bitmapData->copyPixels(bitmapData,tempRect,tempPoint,null(),null(),null());
            					}
            				}
HXLINE( 425)				 ::openfl::geom::Rectangle tempRect1 = tempRect;
HXDLIN( 425)				tempRect1->x = (tempRect1->x + (frameWidth - 1));
HXLINE( 427)				{
HXLINE( 427)					int _g21 = 0;
HXDLIN( 427)					int _g3 = borderX;
HXDLIN( 427)					while((_g21 < _g3)){
HXLINE( 427)						_g21 = (_g21 + 1);
HXDLIN( 427)						int j1 = (_g21 - 1);
HXLINE( 429)						tempPoint->x = ((tempRect->x + j1) + 1);
HXLINE( 430)						bitmapData->copyPixels(bitmapData,tempRect,tempPoint,null(),null(),null());
            					}
            				}
            			}
            		}
HXLINE( 434)		tempPoint->setTo(( (Float)(0) ),( (Float)(0) ));
HXLINE( 435)		tempRect->setTo(( (Float)(0) ),( (Float)(0) ),( (Float)(bitmapData->width) ),( (Float)(1) ));
HXLINE( 436)		{
HXLINE( 436)			int _g22 = 0;
HXDLIN( 436)			int _g31 = verticalFrames;
HXDLIN( 436)			while((_g22 < _g31)){
HXLINE( 436)				_g22 = (_g22 + 1);
HXDLIN( 436)				int i1 = (_g22 - 1);
HXLINE( 438)				tempRect->y = ( (Float)(((i1 * ((frameHeight + (2 * borderY)) + spaceY)) + borderY)) );
HXLINE( 440)				{
HXLINE( 440)					int _g23 = 0;
HXDLIN( 440)					int _g32 = borderY;
HXDLIN( 440)					while((_g23 < _g32)){
HXLINE( 440)						_g23 = (_g23 + 1);
HXDLIN( 440)						int j2 = (_g23 - 1);
HXLINE( 442)						tempPoint->y = ((tempRect->y - ( (Float)(j2) )) - ( (Float)(1) ));
HXLINE( 443)						bitmapData->copyPixels(bitmapData,tempRect,tempPoint,null(),null(),null());
            					}
            				}
HXLINE( 446)				 ::openfl::geom::Rectangle tempRect2 = tempRect;
HXDLIN( 446)				tempRect2->y = (tempRect2->y + (frameHeight - 1));
HXLINE( 448)				{
HXLINE( 448)					int _g4 = 0;
HXDLIN( 448)					int _g5 = borderY;
HXDLIN( 448)					while((_g4 < _g5)){
HXLINE( 448)						_g4 = (_g4 + 1);
HXDLIN( 448)						int j3 = (_g4 - 1);
HXLINE( 450)						tempPoint->y = ((tempRect->y + j3) + 1);
HXLINE( 451)						bitmapData->copyPixels(bitmapData,tempRect,tempPoint,null(),null(),null());
            					}
            				}
            			}
            		}
HXLINE( 455)		bitmapData->unlock(null());
HXLINE( 456)		return bitmapData;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC9(FlxBitmapDataUtil_obj,copyBorderPixels,return )

 ::openfl::display::BitmapData FlxBitmapDataUtil_obj::generateRotations( ::openfl::display::BitmapData brush,hx::Null< int >  __o_rotations,hx::Null< bool >  __o_antiAliasing,hx::Null< bool >  __o_autoBuffer){
            		int rotations = __o_rotations.Default(16);
            		bool antiAliasing = __o_antiAliasing.Default(false);
            		bool autoBuffer = __o_autoBuffer.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_412bf34bd2ca21dd_469_generateRotations)
HXLINE( 470)		int brushWidth = brush->width;
HXLINE( 471)		int brushHeight = brush->height;
HXLINE( 472)		int max;
HXDLIN( 472)		if ((brushHeight > brushWidth)) {
HXLINE( 472)			max = brushHeight;
            		}
            		else {
HXLINE( 472)			max = brushWidth;
            		}
HXLINE( 473)		if (autoBuffer) {
HXLINE( 473)			max = ::Std_obj::_hx_int((( (Float)(max) ) * ((Float)1.5)));
            		}
            		else {
HXLINE( 473)			max = max;
            		}
HXLINE( 475)		int rows = ::Std_obj::_hx_int(::Math_obj::sqrt(( (Float)(rotations) )));
HXLINE( 476)		int columns = ::Math_obj::ceil((( (Float)(rotations) ) / ( (Float)(rows) )));
HXLINE( 477)		Float bakedRotationAngle = (( (Float)(360) ) / ( (Float)(rotations) ));
HXLINE( 479)		int width = (max * columns);
HXLINE( 480)		int height = (max * rows);
HXLINE( 482)		 ::openfl::display::BitmapData result =  ::openfl::display::BitmapData_obj::__alloc( HX_CTX ,width,height,true,0);
HXLINE( 484)		int row = 0;
HXLINE( 485)		int column = 0;
HXLINE( 486)		Float bakedAngle = ( (Float)(0) );
HXLINE( 487)		int halfBrushWidth = ::Std_obj::_hx_int((( (Float)(brushWidth) ) * ((Float)0.5)));
HXLINE( 488)		int halfBrushHeight = ::Std_obj::_hx_int((( (Float)(brushHeight) ) * ((Float)0.5)));
HXLINE( 489)		int midpointX = ::Std_obj::_hx_int((( (Float)(max) ) * ((Float)0.5)));
HXLINE( 490)		int midpointY = ::Std_obj::_hx_int((( (Float)(max) ) * ((Float)0.5)));
HXLINE( 492)		while((row < rows)){
HXLINE( 494)			column = 0;
HXLINE( 495)			while((column < columns)){
HXLINE( 497)				::flixel::util::FlxBitmapDataUtil_obj::matrix->identity();
HXLINE( 498)				::flixel::util::FlxBitmapDataUtil_obj::matrix->translate(( (Float)(-(halfBrushWidth)) ),( (Float)(-(halfBrushHeight)) ));
HXLINE( 499)				::flixel::util::FlxBitmapDataUtil_obj::matrix->rotate((bakedAngle * (::Math_obj::PI / ( (Float)(180) ))));
HXLINE( 500)				::flixel::util::FlxBitmapDataUtil_obj::matrix->translate(( (Float)(((max * column) + midpointX)) ),( (Float)(midpointY) ));
HXLINE( 501)				bakedAngle = (bakedAngle + bakedRotationAngle);
HXLINE( 502)				result->draw(brush,::flixel::util::FlxBitmapDataUtil_obj::matrix,null(),null(),null(),antiAliasing);
HXLINE( 503)				column = (column + 1);
            			}
HXLINE( 505)			midpointY = (midpointY + max);
HXLINE( 506)			row = (row + 1);
            		}
HXLINE( 509)		return result;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(FlxBitmapDataUtil_obj,generateRotations,return )


FlxBitmapDataUtil_obj::FlxBitmapDataUtil_obj()
{
}

bool FlxBitmapDataUtil_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"merge") ) { outValue = merge_dyn(); return true; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"matrix") ) { outValue = ( matrix ); return true; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"compare") ) { outValue = compare_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"getDiff") ) { outValue = getDiff_dyn(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"replaceColor") ) { outValue = replaceColor_dyn(); return true; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"getMemorySize") ) { outValue = getMemorySize_dyn(); return true; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"copyBorderPixels") ) { outValue = copyBorderPixels_dyn(); return true; }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"generateRotations") ) { outValue = generateRotations_dyn(); return true; }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"mergeColorComponent") ) { outValue = mergeColorComponent_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"addSpacesAndBorders") ) { outValue = addSpacesAndBorders_dyn(); return true; }
	}
	return false;
}

bool FlxBitmapDataUtil_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"matrix") ) { matrix=ioValue.Cast<  ::flixel::math::FlxMatrix >(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static hx::StorageInfo *FlxBitmapDataUtil_obj_sMemberStorageInfo = 0;
static hx::StaticInfo FlxBitmapDataUtil_obj_sStaticStorageInfo[] = {
	{hx::fsObject /*  ::flixel::math::FlxMatrix */ ,(void *) &FlxBitmapDataUtil_obj::matrix,HX_("matrix",41,36,c8,bb)},
	{ hx::fsUnknown, 0, null()}
};
#endif

static void FlxBitmapDataUtil_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(FlxBitmapDataUtil_obj::matrix,"matrix");
};

#ifdef HXCPP_VISIT_ALLOCS
static void FlxBitmapDataUtil_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(FlxBitmapDataUtil_obj::matrix,"matrix");
};

#endif

hx::Class FlxBitmapDataUtil_obj::__mClass;

static ::String FlxBitmapDataUtil_obj_sStaticFields[] = {
	HX_("matrix",41,36,c8,bb),
	HX_("merge",b8,a2,c6,05),
	HX_("mergeColorComponent",b2,23,8f,c5),
	HX_("compare",a5,18,69,83),
	HX_("getDiff",bb,0b,ec,14),
	HX_("getMemorySize",98,08,07,4f),
	HX_("replaceColor",8f,5c,eb,3d),
	HX_("addSpacesAndBorders",7e,17,0f,63),
	HX_("copyBorderPixels",8e,6c,7f,76),
	HX_("generateRotations",80,cb,c6,62),
	::String(null())
};

void FlxBitmapDataUtil_obj::__register()
{
	FlxBitmapDataUtil_obj _hx_dummy;
	FlxBitmapDataUtil_obj::_hx_vtable = *(void **)&_hx_dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_("flixel.util.FlxBitmapDataUtil",b3,4e,39,e9);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &FlxBitmapDataUtil_obj::__GetStatic;
	__mClass->mSetStaticField = &FlxBitmapDataUtil_obj::__SetStatic;
	__mClass->mMarkFunc = FlxBitmapDataUtil_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(FlxBitmapDataUtil_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = hx::TCanCast< FlxBitmapDataUtil_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = FlxBitmapDataUtil_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = FlxBitmapDataUtil_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = FlxBitmapDataUtil_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void FlxBitmapDataUtil_obj::__boot()
{
{
            	HX_GC_STACKFRAME(&_hx_pos_412bf34bd2ca21dd_17_boot)
HXDLIN(  17)		matrix =  ::flixel::math::FlxMatrix_obj::__alloc( HX_CTX ,null(),null(),null(),null(),null(),null());
            	}
}

} // end namespace flixel
} // end namespace util
